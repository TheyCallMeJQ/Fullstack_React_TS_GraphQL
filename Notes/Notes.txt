Tutorial reference: https://www.youtube.com/watch?v=I6ypD7qv3Z8&ab_channel=BenAwad

A note on text editors:
I don't give a fuck who you think you are, use VS Code.

A note on extensions:
To see extensions which are currently installed, you can enter into the searchbar command @installed.

VS Code extensions:
- Bracket Pair Colorizer 2 (0.2.0)
- Docker (1.6.0)
- GraphQL for VSCode (1.15.3)
- Prettier - Code formatter (5.7.1)
- Vim (1.17.1) - Disabled for now

How to enable auto-formatting on save for VS Code. 
You can achieve the same result by messing with your settings, which is fine, you can find the relevant config over on the Prettier - Code formatter docs, but you can also do the following, simply via the editor settings:
Code > Preferences > Settings > User. Search for "format", and check "format on save"

Backend init steps:
1. New package.json to backend root
2. Install packages 
    a. devDependencies:
        "@types/node": "^14.11.5",
        "concurrently": "^5.3.0",
        "nodemon": "^2.0.4",
        "ts-node": "^9.0.0",
        "typescript": "^4.0.3"
    b. dependencies:
        "@mikro-orm/cli": "^4.0.7",
        "@mikro-orm/core": "^4.0.7",
        "@mikro-orm/migrations": "^4.0.7",
        "@mikro-orm/postgresql": "^4.0.7",
        "pg": "^8.4.0"    

3. tsconfig.json to backend root
    $ npx tsconfig.json

4. Create the following src/index.ts to test the functionality of the scripts which follow:
//src/index.ts:
console.log('Hello world!');

5. New scripts to package.json (remove comments after copy-paste)
"scripts":[
    //Transpile ts to js, retranspile on file change
    "watch" : "tsc -w",
    //Compile generated js
    "start": "nodemon dist/index.js"
]    

6. Initialize db
    a. if needed, install postgresql 
        $ brew install postgresql
    b. Ensure successful install via 
        $ postgres -V
    c. Ensure existence of postgres default account with the following:
        1. $ psql postgres
        2. postgres=# \du
        3. (Optional) If now you DON'T see postgres account listed, exit and run the following:
            a. $ createuser -s postgres
                  
    d. (Optional) add db scripts to package.json, for instance:
        "pg-start": "brew services start postgresql",
        "pg-stop" : "brew services stop postgresql"

    e. (After starting postgresql instance via 'pg-start' script defined above) create new db.
        $ createdb [DB_NAME]

    d. Create a new entity, in accordance with mikro-orm docs: https://mikro-orm.io/docs/defining-entities/
    //entities/Post.ts:
    import { Entity, PrimaryKey, Property } from "@mikro-orm/core";

    @Entity()
    export class Post {
        @PrimaryKey()
        id!: number;

        @Property({ type: "date" })
        createdAt = new Date();

        @Property({ type: "date", onUpdate: () => new Date() })
        updatedAt = new Date();

        @Property({ type: "text" })
        title!: string;
    }


    e. Set up MikroORM CLI to allow for ops to db.
        i. Add to package.json (Source: https://mikro-orm.io/docs/installation#setting-up-the-commandline-tool):
        {
            "name": "your-app",
            "dependencies": { ... },
            "mikro-orm": {
                "useTsNode": true,
                "configPaths": [
                "./src/mikro-orm.config.ts",
                "./dist/mikro-orm.config.js"
                ]
            }
        }
        
        ii. Create 'src/mikro-orm.config.ts' with the following:
        //Source: https://mikro-orm.io/docs/migrations/#configuration
        import { MikroORM } from "@mikro-orm/core";
        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";

        import path from "path";

        export default {
            migrations: {
                path: path.join(__dirname, "./migrations"), // path to the folder with migrations
                pattern: /^[\w-]+\d+\.[tj]s$/, // regex pattern for the migration files (.js or .ts)
            },
            dbName: "lireddit",
            entities: [Post],
            type: "postgresql",
            debug: !__prod__,
        } as Parameters<typeof MikroORM.init>[0];

        iii. Have the following as src/index.ts
        //src/index.ts
        import { MikroORM } from "@mikro-orm/core";
        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";

        import microConfig from "./mikro-orm.config";

        const main = async () => {
            const orm = await MikroORM.init(microConfig);

            //Create a new Post (does not affect db)
            const post = orm.em.create(Post, { title: "My first post" });
            await orm.em.persistAndFlush(post);
            console.log("--------------SQL 2-------------------");
            await orm.em.persistAndFlush(post);
        };

        main().catch((e) => {
            console.log(e);
        });

        
        iv. Create MikroORM migration via CLI command 
        (Source: https://mikro-orm.io/docs/migrations/#using-via-cli)
            $ npx mikro-orm migration:create
        If running the above gives you the "role postgres doesn't exist" error (which means there's no defined postgres user), then see 5.c.3, '(Optional) If now you DON'T see postgres account listed, exit and run the following'.

        v. Delete `dist` folder, for now, to avoid problems later with duplicates.

        vi. Automate migration by including it in src/index.ts. Modify src/index.ts to the following. Test success with `start` and `watch` command chain.
        //src/index.ts
        import { MikroORM } from "@mikro-orm/core";

        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";
        import microConfig from "./mikro-orm.config";

        const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                //Create a new Post (does not affect db)
                const post = orm.em.create(Post, { title: "My first post" });
                await orm.em.persistAndFlush(post);
            };

            main().catch((e) => {
            console.log(e);
        });
    7. Initialize server
        a. Add to dependencies:
            "apollo-server-express": "^2.18.2",
            "express": "^4.17.1",
            "graphql": "^15.3.0",
            "type-graphql": "^1.0.0"
        b. Add to devDependencies
            "@types/express": "^4.17.8",
        c. Test express works properly with the following:
            1. ensure src/index.ts matches:
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                const app = express();
                const PORT = 4000;

                app.get("/", (req, res) => {
                    res.send("Hello world from Express!");
                });

                app.listen(PORT, () => {
                    console.log(`Server listening on port ${PORT}`);
                });
            };

            main().catch((e) => {
                console.log(e);
            });

            2. Navigate to http://localhost:4000, you should receive "Hello world from Express!"
        d. Set up apollo-server-express
            i. Create HelloResolver class
            //src/resolvers/hello.ts  
            import { Query, Resolver } from "type-graphql";

            @Resolver()
            export class HelloResolver {
                @Query(() => String)
                hello() {
                    return "Hello world!";
                }
            }
            ii. Implement hello resolver in apollo-server graphql schema
            //src/index.ts
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";
            import { ApolloServer } from "apollo-server-express";
            import { buildSchema } from "type-graphql";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            import { HelloResolver } from "./resolvers/hello";

            const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                const PORT = 4000;
                const app = express();

                const apolloServer = new ApolloServer({
                    schema: await buildSchema({
                    resolvers: [HelloResolver],
                    validate: false,
                    }),
                });

                apolloServer.applyMiddleware({ app });

                app.listen(PORT, () => {
                    console.log(`Server listening on port ${PORT}`);
                });
            };

            main().catch((e) => {
                console.log(e);
            });
            iii. Verify successful graphQL endpoint by navigating to http://localhost:4000 and trying out the `hello` query. You should see as output 'Hello world'
        e. Combine apollo-server-express with MikroORM for some CRUD ops
            i. Modify Post entity to be a GraphQL type via @ObjectType declaration.
            //src/entities/Post.ts
            import { Entity, PrimaryKey, Property } from "@mikro-orm/core";
            import { Field, ObjectType } from "type-graphql";

            @ObjectType()
            @Entity()
            export class Post {
            @Field()
            @PrimaryKey()
            id!: number;

            @Field()
            @Property({ type: "date" })
            createdAt = new Date();

            @Field()
            @Property({ type: "date", onUpdate: () => new Date() })
            updatedAt = new Date();

            @Field()
            @Property({ type: "text" })
            title!: string;
            }

            ii. Change src/index.ts to include context into apolloServer.
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";
            import { ApolloServer } from "apollo-server-express";
            import { buildSchema } from "type-graphql";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            import { HelloResolver } from "./resolvers/hello";
            import { PostResolver } from "./resolvers/post";

            const main = async () => {
            //Connect to MikroORM
            const orm = await MikroORM.init(microConfig);
            //Run migrations
            await orm.getMigrator().up();

            const PORT = 4000;
            const app = express();

            const apolloServer = new ApolloServer({
                schema: await buildSchema({
                resolvers: [HelloResolver, PostResolver],
                validate: false,
                }),
                context: () => ({ em: orm.em }),
            });

            apolloServer.applyMiddleware({ app });

            app.listen(PORT, () => {
                console.log(`Server listening on port ${PORT}`);
            });
            };

            main().catch((e) => {
                console.log(e);
            });

            iii. Define MyContext type in types.ts.
            Note: find the type of em by hovering over orm.em, in /src/index.ts, and copy-pasting the type.
            //types.ts
            import { EntityManager, IDatabaseDriver, Connection } from "@mikro-orm/core";

            export type MyContext {
                em: EntityManager<any> & EntityManager<IDatabaseDriver<Connection>>
            }

            iv. Define PostResolver class, using context.
            import { Post } from "src/entities/Post";
            import { Query, Resolver } from "type-graphql";

            @Resolver()
            export class PostResolver {
                @Query(() => [Post])
                hello() {
                    return "Hello world!";
                }
            }

            v. Define post resolvers

            



  
    

What does it do for us to implement our HelloResolver in our src/index.ts schema definition? What this does for us is it defines a graphQL endpoint for our queries.


Before losing your mind on debugging:
Make sure your dist looks the way it should. It's possible that over the course of programming, it gets filled up with a lot of trash (or duplicates from slightly different files). The solution? Erase dist and re-run our `start` and `watch` script, to remake a fresh one.

A note on the purpose of our mikro-orm.config.ts:
We make this src/mikro-orm.config.ts in order to be able to access our custom data types from our MikroORM CLI.

A note on why not to use 'ts-node': 
- it's slow
- when we get to production, we don't use ts-node; we compile to JS and execute that. We elect not to use ts-node to be closer to the production environment, in dev
Our solution to ts-node?
- A 'watch' script executing typescript with the watch flag, to monitor file changes to src/index.ts; spits out a dist build (JS) on file change.
- A 'dev' script to execute 'nodemon' on our produced dist directory, coming from the watch script. To the difference of 'node', 'nodemon' will listen for changes made to our compiled dist file, resulting from our watch script.
Note that the two points above must be two scripts running in tandem. We can do this either in two separate terminal instances, or at once via 'concurrently' package.

A note on the difference between orm.em.create, orm.em.persistAndFlush and orm.em.nativeInsert:

A note on node `path` and `__dirname`
These variables come installed in node, and basically they help us ensure that we're running things from the right place, and we have access to the imports we need. __dirname is a pre-defined global variable whose value corresponds to the absolute path leading to the file it's called in (at run time, which is pertinent for us, because we're transpiling before running).

A note on migrations in MikroORM.
After running the $ npx mikro-orm migration:create, from https://mikro-orm.io/docs/migrations/#using-via-cli, we'll have a new migrations directory with the literal SQL generated by our data definitions in our entities. In the migrations, we can see the data types of all of our properties.
We can actually automate the migrations of our 
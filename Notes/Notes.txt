Tutorial reference: https://www.youtube.com/watch?v=I6ypD7qv3Z8&ab_channel=BenAwad

A note on text editors:
I don't give a fuck who you think you are, use VS Code.

A note on extensions:
To see extensions which are currently installed, you can enter into the searchbar command @installed.

VS Code extensions:
- Bracket Pair Colorizer 2 (0.2.0)
- Docker (1.6.0)
- GraphQL for VSCode (1.15.3)
- Prettier - Code formatter (5.7.1)
- Vim (1.17.1) - Disabled for now

How to enable auto-formatting on save for VS Code. 
You can achieve the same result by messing with your settings, which is fine, you can find the relevant config over on the Prettier - Code formatter docs, but you can also do the following, simply via the editor settings:
Code > Preferences > Settings > User. Search for "format", and check "format on save"

Backend init steps:
1. New package.json to backend root
2. Install packages 
    a. devDependencies:
        "@types/node": "^14.11.5",
        "concurrently": "^5.3.0",
        "nodemon": "^2.0.4",
        "ts-node": "^9.0.0",
        "typescript": "^4.0.3"
    b. dependencies:
        "@mikro-orm/cli": "^4.0.7",
        "@mikro-orm/core": "^4.0.7",
        "@mikro-orm/migrations": "^4.0.7",
        "@mikro-orm/postgresql": "^4.0.7",
        "pg": "^8.4.0"    

3. tsconfig.json to backend root
    $ npx tsconfig.json

4. Create the following src/index.ts to test the functionality of the scripts which follow:
//src/index.ts:
console.log('Hello world!');

5. New scripts to package.json (remove comments after copy-paste)
"scripts":[
    //Transpile ts to js, retranspile on file change
    "watch" : "tsc -w",
    //Compile generated js
    "start": "nodemon dist/index.js"
]    

6. Initialize db
    a. if needed, install postgresql 
        $ brew install postgresql
    b. Ensure successful install via 
        $ postgres -V
    c. Ensure existence of postgres default account with the following:
        1. $ psql postgres
        2. postgres=# \du
        3. (Optional) If now you DON'T see postgres account listed, exit and run the following:
            a. $ createuser -s postgres
                  
    d. (Optional) add db scripts to package.json, for instance:
        "pg-start": "brew services start postgresql",
        "pg-stop" : "brew services stop postgresql"

    e. (After starting postgresql instance via 'pg-start' script defined above) create new db.
        $ createdb [DB_NAME]

    d. Create a new entity, in accordance with mikro-orm docs: https://mikro-orm.io/docs/defining-entities/
    //entities/Post.ts:
    import { Entity, PrimaryKey, Property } from "@mikro-orm/core";

    @Entity()
    export class Post {
        @PrimaryKey()
        id!: number;

        @Property({ type: "date" })
        createdAt = new Date();

        @Property({ type: "date", onUpdate: () => new Date() })
        updatedAt = new Date();

        @Property({ type: "text" })
        title!: string;
    }


    e. Set up MikroORM CLI to allow for ops to db.
        i. Add to package.json (Source: https://mikro-orm.io/docs/installation#setting-up-the-commandline-tool):
        {
            "name": "your-app",
            "dependencies": { ... },
            "mikro-orm": {
                "useTsNode": true,
                "configPaths": [
                "./src/mikro-orm.config.ts",
                "./dist/mikro-orm.config.js"
                ]
            }
        }
        
        ii. Create 'src/mikro-orm.config.ts' with the following:
        //Source: https://mikro-orm.io/docs/migrations/#configuration
        import { MikroORM } from "@mikro-orm/core";
        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";

        import path from "path";

        export default {
            migrations: {
                path: path.join(__dirname, "./migrations"), // path to the folder with migrations
                pattern: /^[\w-]+\d+\.[tj]s$/, // regex pattern for the migration files (.js or .ts)
            },
            dbName: "lireddit",
            entities: [Post],
            type: "postgresql",
            debug: !__prod__,
        } as Parameters<typeof MikroORM.init>[0];

        iii. Have the following as src/index.ts
        //src/index.ts
        import { MikroORM } from "@mikro-orm/core";
        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";

        import microConfig from "./mikro-orm.config";

        const main = async () => {
            const orm = await MikroORM.init(microConfig);

            //Create a new Post (does not affect db)
            const post = orm.em.create(Post, { title: "My first post" });
            await orm.em.persistAndFlush(post);
            console.log("--------------SQL 2-------------------");
            await orm.em.persistAndFlush(post);
        };

        main().catch((e) => {
            console.log(e);
        });

        
        iv. Create MikroORM migration via CLI command 
        (Source: https://mikro-orm.io/docs/migrations/#using-via-cli)
            $ npx mikro-orm migration:create
        If running the above gives you the "role postgres doesn't exist" error (which means there's no defined postgres user), then see 5.c.3, '(Optional) If now you DON'T see postgres account listed, exit and run the following'.

        v. Delete `dist` folder, for now, to avoid problems later with duplicates.

        vi. Automate migration by including it in src/index.ts. Modify src/index.ts to the following. Test success with `start` and `watch` command chain.
        //src/index.ts
        import { MikroORM } from "@mikro-orm/core";

        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";
        import microConfig from "./mikro-orm.config";

        const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                //Create a new Post (does not affect db)
                const post = orm.em.create(Post, { title: "My first post" });
                await orm.em.persistAndFlush(post);
            };

            main().catch((e) => {
            console.log(e);
        });
    7. Initialize server
        a. Add to dependencies:
            "apollo-server-express": "^2.18.2",
            "express": "^4.17.1",
            "graphql": "^15.3.0",
            "type-graphql": "^1.0.0",
            "reflect-metadata": "^0.1.13"
        b. Add to devDependencies
            "@types/express": "^4.17.8",
        c. Test express works properly with the following:
            1. ensure src/index.ts matches:
            import "reflect-metadata";
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                const app = express();
                const PORT = 4000;

                app.get("/", (req, res) => {
                    res.send("Hello world from Express!");
                });

                app.listen(PORT, () => {
                    console.log(`Server listening on port ${PORT}`);
                });
            };

            main().catch((e) => {
                console.log(e);
            });

            2. Navigate to http://localhost:4000, you should receive "Hello world from Express!"
        d. Set up apollo-server-express
            i. Create HelloResolver class
            //src/resolvers/hello.ts  
            import { Query, Resolver } from "type-graphql";

            @Resolver()
            export class HelloResolver {
                @Query(() => String)
                hello() {
                    return "Hello world!";
                }
            }
            ii. Implement hello resolver in apollo-server graphql schema
            //src/index.ts
            import "reflect-metadata";
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";
            import { ApolloServer } from "apollo-server-express";
            import { buildSchema } from "type-graphql";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            import { HelloResolver } from "./resolvers/hello";

            const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                const PORT = 4000;
                const app = express();

                const apolloServer = new ApolloServer({
                    schema: await buildSchema({
                    resolvers: [HelloResolver],
                    validate: false,
                    }),
                });

                apolloServer.applyMiddleware({ app });

                app.listen(PORT, () => {
                    console.log(`Server listening on port ${PORT}`);
                });
            };

            main().catch((e) => {
                console.log(e);
            });
            iii. Verify successful graphQL endpoint by navigating to http://localhost:4000 and trying out the `hello` query. You should see as output 'Hello world'
        e. Combine apollo-server-express with MikroORM for some CRUD ops
            i. Modify Post entity to be a GraphQL type via @ObjectType declaration, specifying the return types of each field.
            //src/entities/Post.ts
            import { Entity, PrimaryKey, Property } from "@mikro-orm/core";
            import { Field, Int, ObjectType } from "type-graphql";

            @ObjectType()
            @Entity()
            export class Post {
                @Field(() => Int)
                @PrimaryKey()
                id!: number;

                @Field(() => String)
                @Property({ type: "date" })
                createdAt = new Date();

                @Field(() => String)
                @Property({ type: "date", onUpdate: () => new Date() })
                updatedAt = new Date();

                @Field()
                @Property({ type: "text" })
                title!: string;
            }


            ii. Change src/index.ts to include context into apolloServer.
            import "reflect-metadata";
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";
            import { ApolloServer } from "apollo-server-express";
            import { buildSchema } from "type-graphql";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            import { HelloResolver } from "./resolvers/hello";
            import { PostResolver } from "./resolvers/post";

            const main = async () => {
                //Connect to MikroORM
                const orm = await MikroORM.init(microConfig);
                //Run migrations
                await orm.getMigrator().up();

                const PORT = 4000;
                const app = express();

                const apolloServer = new ApolloServer({
                    schema: await buildSchema({
                    resolvers: [HelloResolver, PostResolver],
                    validate: false,
                    }),
                    context: () => ({ em: orm.em }),
                });

                apolloServer.applyMiddleware({ app });

                app.listen(PORT, () => {
                    console.log(`Server listening on port ${PORT}`);
                });
            };

            main().catch((e) => {
                console.log(e);
            });

            iii. Define MyContext type in types.ts.
            Note: find the type of em by hovering over orm.em, in /src/index.ts, and copy-pasting the type.
            //types.ts
            import { EntityManager, IDatabaseDriver, Connection } from "@mikro-orm/core";

            export type MyContext {
                em: EntityManager<any> & EntityManager<IDatabaseDriver<Connection>>
            }

            iv. Define PostResolver class, using context, with default `hello world` resolver.
            import { Post } from "src/entities/Post";
            import { Query, Resolver } from "type-graphql";

            @Resolver()
            export class PostResolver {
                @Query(() => [Post])
                hello() {
                    return "Hello world!";
                }
            }

            v. Define post resolvers
            import { Post } from "../entities/Post";
            import { MyContext } from "src/types";
            import { Arg, Ctx, Int, Mutation, Query, Resolver } from "type-graphql";

            @Resolver()
            export class PostResolver {
            @Query(() => [Post])
            posts(@Ctx() { em }: MyContext): Promise<Post[]> {
                return em.find(Post, {});
            }

            @Query(() => Post, { nullable: true })
            post(
                @Ctx() { em }: MyContext,
                @Arg("id", () => Int) id: number
            ): Promise<Post | null> {
                const post = em.findOne(Post, { id });
                return post;
            }

            @Mutation(() => Post)
            async createPost(
                @Ctx() { em }: MyContext,
                @Arg("title", () => String) title: string
            ): Promise<Post> {
                const post = em.create(Post, { title });
                await em.persistAndFlush(post);
                return post;
            }

            @Mutation(() => Post, { nullable: true })
            async updatePost(
                @Ctx() { em }: MyContext,
                @Arg("id", () => Number) id: number,
                @Arg("title", () => String, { nullable: true }) title: string
            ): Promise<Post | null> {
                const post = await em.findOne(Post, { id });
                if (!post) {
                    return null;
                }
                if (typeof title !== undefined) {
                    post.title = title;
                    await em.persistAndFlush(post);
                }
                return post;
            }

            @Mutation(() => Boolean)
            async deletePost(
                @Ctx() { em }: MyContext,
                @Arg("id", () => Number) id: number
            ): Promise<boolean> {
                try {
                await em.nativeDelete(Post, { id });
                return true;
                } catch (e) {
                console.log("Error", e);
                }
                return false;
            }
            }

    8. Authentication
        i. create:migration script to make life easier
            "create:migration": "mikro-orm migration:create"
        ii. Create User entity
            import { Entity, PrimaryKey, Property } from "@mikro-orm/core";
            import { Field, Int, ObjectType } from "type-graphql";

            @ObjectType()
            @Entity()
            export class User {
                @Field(() => Int)
                @PrimaryKey()
                id!: number;

                @Field(() => String)
                @Property({ type: "date" })
                createdAt = new Date();

                @Field(() => String)
                @Property({ type: "date", onUpdate: () => new Date() })
                updatedAt = new Date();

                @Property({ type: "text", unique: true })
                username!: string;

                @Property({ type: "text" })
                password!: string;
            }
        iii. Add User entity to micro-orm.config.ts
        import { MikroORM } from "@mikro-orm/core";
        import path from "path";
        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";
        import { User } from "./entities/User";

        export default {
            migrations: {
                path: path.join(__dirname, "./migrations"), // path to the folder with migrations
                pattern: /^[\w-]+\d+\.[tj]s$/, // regex pattern for the migration files (.js or .ts)
            },
            dbName: "lireddit",
            entities: [Post, User],
            type: "postgresql",
            debug: !__prod__,
        } as Parameters<typeof MikroORM.init>[0];

        iii. Create new migration via yarn create:migration`

        iv. Install to dependencies `argon2` (for password hashing)

        v. User resolvers
            - Create UserResolver in ./resolvers/user.ts
            - Add UserResolver to ApolloServer schema `resolvers`, in ./src/index.

            //resolvers/user.ts
            import { MyContext } from "src/types";
            import argon2 from "argon2";
            import {
            Arg,
            Ctx,
            Field,
            InputType,
            Mutation,
            ObjectType,
            Resolver,
            } from "type-graphql";
            import { User } from "../entities/User";

            @InputType()
            class UsernamePasswordInput {
                @Field()
                username: string;
                @Field(() => String)
                password: string;
            }

            @ObjectType()
            class FieldError {
                @Field(() => String)
                field: string;
                @Field(() => String)
                message: string;
            }

            @ObjectType()
            class UserResponse {
                @Field(() => [FieldError], { nullable: true })
                errors?: FieldError[];
                @Field(() => User, { nullable: true })
                user?: User;
            }

            @Resolver()
            export class UserResolver {
                @Mutation(() => UserResponse)
                async register(
                    @Ctx() { em }: MyContext,
                    @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
                ): Promise<UserResponse> {
                    if (input.username.length <= 2) {
                    return {
                        errors: [
                        {
                            field: "username",
                            message: "Length of provided username must be greater than 2.",
                        },
                        ],
                    };
                    }
                    if (input.password.length <= 3) {
                    return {
                        errors: [
                        {
                            field: "password",
                            message: "Length of provided password must be greater than 3.",
                        },
                        ],
                    };
                    }
                    const hashedPassword = await argon2.hash(input.password);
                    const user = em.create(User, {
                    username: input.username,
                    password: hashedPassword,
                    });
                    try {
                    await em.persistAndFlush(user);
                    } catch (err) {
                    console.log("message", err.message);
                    if (err.code === "23505" || err.detail.includes("already exists")) {
                        em.clear();
                        //duplicate username error
                        return {
                        errors: [
                            {
                            message: "This username already exists",
                            field: "username",
                            },
                        ],
                        };
                    }
                    return {
                        errors: [
                        {
                            message: "Something went wrong",
                            field: "Unknown",
                        },
                        ],
                    };
                    }
                    return { user };
                }

                @Mutation(() => UserResponse)
                async login(
                    @Ctx() { em }: MyContext,
                    @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
                ): Promise<UserResponse> {
                    const user = await em.findOne(User, { username: input.username });
                    if (!user) {
                    return {
                        errors: [
                        {
                            field: "username",
                            message: "That username doesn't exist",
                        },
                        ],
                    };
                    }
                    const hashedPassword = user.password;
                    const isGoodPassword = await argon2.verify(hashedPassword, input.password);
                    if (!isGoodPassword) {
                    return {
                        errors: [
                        {
                            field: "password",
                            message: "That password is incorrect",
                        },
                        ],
                    };
                    }
                    return { user };
                }
            }

        
    8. User session 
        i. Install redis - https://formulae.brew.sh/formula/redis
        ii. Create new redis scripts
            "start-redis": "brew services start redis",
            "stop-redis": "brew services stop redis",
        iii. Install to dependencies:
            "connect-redis": "^5.0.0",
            "express-session": "^1.17.1",
            "redis": "^3.0.2",
        iv. Install to devDependencies:
            "@types/connect-redis": "^0.0.14",
            "@types/express-session": "^1.17.0",
            "@types/redis": "^2.8.27",
        v. Add request and response to custom context definition, in ./src/types.ts
        import { EntityManager, IDatabaseDriver, Connection } from "@mikro-orm/core";
        import { Request, Response } from "express";

        export type MyContext = {
            em: EntityManager<any> & EntityManager<IDatabaseDriver<Connection>>;
            req: Request & { session: Express.Session };
            res: Response;
        };

        v. Add redis to app in ./src/index.ts; redis config, and add to context
        //src/index.ts
        import "reflect-metadata";
        import { MikroORM } from "@mikro-orm/core";
        import express from "express";
        import { ApolloServer } from "apollo-server-express";
        import { buildSchema } from "type-graphql";

        import { __prod__ } from "./constants";
        import microConfig from "./mikro-orm.config";

        import { HelloResolver } from "./resolvers/hello";
        import { PostResolver } from "./resolvers/post";
        import { UserResolver } from "./resolvers/user";

        import connectRedis from "connect-redis";
        import redis from "redis";
        import session from "express-session";

        const main = async () => {
            //Connect to MikroORM
            const orm = await MikroORM.init(microConfig);
            //Run migrations
            await orm.getMigrator().up();

            const PORT = 4000;
            const app = express();

            const RedisStore = connectRedis(session);
            const redisClient = redis.createClient();

            app.use(
                session({
                name: "qid",
                store: new RedisStore({ client: redisClient, disableTouch: true }),
                cookie: {
                    //No access to cookie from frontend
                    httpOnly: true,
                    //Set cookie lifespan to 10 years
                    maxAge: 1000 * 60 * 60 * 24 * 365 * 10,
                    //Only work for https
                    secure: __prod__,
                    sameSite: 'lax',//csrf

                },
                saveUninitialized: false,
                secret: "hbfwelmxlzwjdcdllw",
                resave: false,
                })
            );

            const apolloServer = new ApolloServer({
                schema: await buildSchema({
                    resolvers: [HelloResolver, PostResolver, UserResolver],
                    validate: false,
                }),
                context: ({req, res}) => ({ em: orm.em, req, res }),
            });


            apolloServer.applyMiddleware({ app });

            app.listen(PORT, () => {
                console.log(`Server listening on port ${PORT}`);
            });
        };

        main().catch((e) => {
            console.log(e);
        });
        
        vi. Add user id to request session on login
        //src/resolvers/user
        ...
        @Mutation(() => UserResponse)
        async login(
            @Ctx() { em, req }: MyContext,
            @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
        ): Promise<UserResponse> {
            const user = await em.findOne(User, { username: input.username });
            if (!user) {
            return {
                errors: [
                {
                    field: "username",
                    message: "That username doesn't exist",
                },
                ],
            };
            }
            const hashedPassword = user.password;
            const isGoodPassword = await argon2.verify(hashedPassword, input.password);
            if (!isGoodPassword) {
            return {
                errors: [
                {
                    field: "password",
                    message: "That password is incorrect",
                },
                ],
            };
            }

            req.session.userId = user.id; //<-- set to session here
            return { user };
        }
        ...

        vii. Test everything on local playground
            NOTE: For this to work, you must go into the local playground settings and set 
                "request.credentials":"include"
        Delete cookies via DevTools > Application > Cookies
        Hit login, with proper credentials, and observe the results; you should see a cookie qid.

        viii. Implement user log in on register, implement me query
        import { MyContext } from "src/types";
        import argon2 from "argon2";
        import {
        Arg,
        Ctx,
        Field,
        InputType,
        Mutation,
        Query,
        ObjectType,
        Resolver,
        } from "type-graphql";
        import { User } from "../entities/User";

        @InputType()
        class UsernamePasswordInput {
        @Field()
        username: string;
        @Field(() => String)
        password: string;
        }

        @ObjectType()
        class FieldError {
        @Field(() => String)
        field: string;
        @Field(() => String)
        message: string;
        }

        @ObjectType()
        class UserResponse {
        @Field(() => [FieldError], { nullable: true })
        errors?: FieldError[];
        @Field(() => User, { nullable: true })
        user?: User;
        }

        @Resolver()
        export class UserResolver {
        @Query(() => User, { nullable: true })
        async me(@Ctx() { req, em }: MyContext) {
            if (!req.session.userId) {
            return null;
            }
            const user = await em.findOne(User, { id: req.session.userId });
            return user;
        }

        @Mutation(() => UserResponse)
        async register(
            @Ctx() { em, req }: MyContext,
            @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
        ): Promise<UserResponse> {
            if (input.username.length <= 2) {
            return {
                errors: [
                {
                    field: "username",
                    message: "Length of provided username must be greater than 2.",
                },
                ],
            };
            }
            if (input.password.length <= 3) {
            return {
                errors: [
                {
                    field: "password",
                    message: "Length of provided password must be greater than 3.",
                },
                ],
            };
            }
            const hashedPassword = await argon2.hash(input.password);
            const user = em.create(User, {
            username: input.username,
            password: hashedPassword,
            });
            try {
            await em.persistAndFlush(user);
            } catch (err) {
            console.log("message", err.message);
            if (err.code === "23505" || err.detail.includes("already exists")) {
                em.clear();
                //duplicate username error
                return {
                errors: [
                    {
                    message: "This username already exists",
                    field: "username",
                    },
                ],
                };
            }
            return {
                errors: [
                {
                    message: "Something went wrong",
                    field: "Unknown",
                },
                ],
            };
            }

            //Store user ID on session
            //This will add a cookie on the session
            //Keep the user logged in
            req.session.userId = user.id;

            return { user };
        }

        @Mutation(() => UserResponse)
        async login(
            @Ctx() { em, req }: MyContext,
            @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
        ): Promise<UserResponse> {
            const user = await em.findOne(User, { username: input.username });
            if (!user) {
            return {
                errors: [
                {
                    field: "username",
                    message: "That username doesn't exist",
                },
                ],
            };
            }
            const hashedPassword = user.password;
            const isGoodPassword = await argon2.verify(hashedPassword, input.password);
            if (!isGoodPassword) {
            return {
                errors: [
                {
                    field: "password",
                    message: "That password is incorrect",
                },
                ],
            };
            }

            req.session.userId = user.id;
            return { user };
        }
        }
        

Frontend:
1. Use nextJS with ChakraUI: https://github.com/vercel/next.js/tree/canary/examples/with-chakra-ui
See https://chakra-ui.com/getting-started for more info on their services, we're going to be using their FormControl components
2. Remove all components, replace index.js with default Hello world div, replace extensions of index, _app, and theme to tsx.
3. Add to devDependencies:
    "@types/node": "^14.11.8",
    "typescript": "^4.0.3"
4. Add to dependencies:
    "formik": "^2.2.0",
5. Create generic InputField component
    import {
    FormControl,
    FormLabel,
    Input,
    FormErrorMessage,
    } from "@chakra-ui/core";
    import { useField } from "formik";
    import React, { InputHTMLAttributes } from "react";

    type InputFieldProps = InputHTMLAttributes<HTMLInputElement> & {
    label: string;
    name: string;
    };

    export const InputField: React.FC<InputFieldProps> = ({
    label,
    size: _,
    ...props
    }) => {
    const [field, { error }] = useField(props);

    return (
        <FormControl isInvalid={!!error}>
        <FormLabel htmlFor={field.name}>{label}</FormLabel>
        <Input {...field} {...props} id={field.name} />
        {error ? <FormErrorMessage>{error}</FormErrorMessage> : null}
        </FormControl>
    );
    };

5. Create register page   
    import React from "react";
    import { Formik, Form } from "formik";
    import {
    Box,
    Button,
    FormControl,
    FormErrorMessage,
    FormLabel,
    Input,
    } from "@chakra-ui/core";
    import { Wrapper } from "../components/Wrapper";
    import { InputField } from "../components/InputField";
    import { useMutation } from "urql";

    const REGISTER_MUTATION = `
    mutation Register($username: String!, $password:String!){
        register(input: {username: $username, password: $password}){
        errors{
            field
            message
        }
        user{
            id
            username
        }
        }
    }
    `;

    interface registerProps {}

    const Register: React.FC<registerProps> = ({}) => {
    const [{ data, error }, register] = useMutation(REGISTER_MUTATION);

    return (
        <Wrapper variant="small">
        <Formik
            initialValues={{ username: "", password: "" }}
            onSubmit={(values) => {
            console.log(values);
            //return promise to end spinner on resolve
            return register(values);
            }}
        >
            {({ isSubmitting }) => (
            <Form>
                <InputField
                label="Username"
                placeholder="username"
                name="username"
                />
                <Box mt={4}>
                <InputField
                    label="Password"
                    placeholder="password"
                    name="password"
                    type="password"
                />
                </Box>
                <Button
                mt={4}
                isLoading={isSubmitting}
                type="submit"
                variantColor="teal"
                >
                Submit
                </Button>
            </Form>
            )}
        </Formik>
        </Wrapper>
    );
    };

    export default Register;


6. Set up GraphQL URQL client
https://formidable.com/open-source/urql/docs/
    a. add to frontend dependencies
        "graphql": "^15.3.0",
        "urql": "^1.10.1"
    b. Create urql client in _app.tsx
        import { ThemeProvider, CSSReset, ColorModeProvider } from "@chakra-ui/core";

        import theme from "../theme";

        import { createClient, Provider } from "urql";
        const client = createClient({
        url: "http://localhost:4000/graphql",
            fetchOptions: {
                credentials: "include",
            },
        });

        function MyApp({ Component, pageProps }) {
        return (
            <Provider value={client}>
                <ThemeProvider theme={theme}>
                    <ColorModeProvider>
                    <CSSReset />
                    <Component {...pageProps} />
                    </ColorModeProvider>
                </ThemeProvider>
            </Provider>
        );
        }

        export default MyApp;
    
    c. Add to backend dependencies
        "cors": "^2.8.5",
    d. Add to backend devDependencies
        "@types/cors": "^2.8.8",  
    e. Add cors to backend app on src/index.ts
    import "reflect-metadata";
    import { MikroORM } from "@mikro-orm/core";
    import express from "express";
    import { ApolloServer } from "apollo-server-express";
    import { buildSchema } from "type-graphql";

    import { __prod__ } from "./constants";
    import microConfig from "./mikro-orm.config";

    import { HelloResolver } from "./resolvers/hello";
    import { PostResolver } from "./resolvers/post";
    import { UserResolver } from "./resolvers/user";

    import connectRedis from "connect-redis";
    import redis from "redis";
    import session from "express-session";

    import cors from "cors";

    const main = async () => {
        //Connect to MikroORM
        const orm = await MikroORM.init(microConfig);
        //Run migrations
        await orm.getMigrator().up();

        const PORT = 4000;
        const app = express();

        const RedisStore = connectRedis(session);
        const redisClient = redis.createClient();

        app.use(
            cors({
                origin: "http://localhost:3000",
                credentials: true,
            })
        );

        app.use(
            session({
                name: "qid",
                store: new RedisStore({ client: redisClient, disableTouch: true }),
                cookie: {
                    //No access to cookie from frontend
                    httpOnly: true,
                    //Set cookie lifespan to 10 years
                    maxAge: 1000 * 60 * 60 * 24 * 365 * 10,
                    //Only work for https
                    secure: __prod__,
                    sameSite: "lax", //csrf
                },
                saveUninitialized: false,
                secret: "hbfwelmxlzwjdcdllw",
                resave: false,
            })
        );

        const apolloServer = new ApolloServer({
            schema: await buildSchema({
                resolvers: [HelloResolver, PostResolver, UserResolver],
                validate: false,
            }),
            context: ({ req, res }) => ({ em: orm.em, req, res }),
        });

        apolloServer.applyMiddleware({
            app,
            cors: false,
        });

        app.listen(PORT, () => {
            console.log(`Server listening on port ${PORT}`);
        });
    };

    main().catch((e) => {
        console.log(e);
    });
      
7. Ensure types returned from our mutators are of desired Typescript types
    a. Install GraphQL code generator
    https://graphql-code-generator.com/docs/getting-started/installation
    Note: We already have graphql, so we're just going to want to add to frontend devDependencies:
        "@graphql-codegen/cli": "^1.17.10",
    We're then going to proceed with the initialization wizard: https://graphql-code-generator.com/docs/getting-started/installation#initialization-wizard

    jq@Jacques-Philippes-MacBook-Air frontend % yarn graphql-codegen init
    yarn run v1.22.5
    $ /Users/jq/Desktop/Learning/Fullstack_React_GraphQL_Typescript_Tutorial/Application/frontend/node_modules/.bin/graphql-codegen init

    Welcome to GraphQL Code Generator!
    Answer few questions and we will setup everything for you.
  
    ? What type of application are you building? Application built with React
    ? Where is your schema?: (path or url) http://localhost:4000/graphql
    ? Where are your operations and fragments?: src/graphql/**/*.graphql
    ? Pick plugins: TypeScript (required by other typescript plugins), TypeScript Operations (operations and fragments)
    ? Where to write the output: src/generated/graphql.tsx
    ? Do you want to generate an introspection file? No
    ? How to name the config file? codegen.yml
    ? What script in package.json should run the codegen? gen

    Notice after this that we have a new 'gen' script in package.json.

    b. Edit codegen.yml to:
        overwrite: true
        schema: "http://localhost:4000/graphql"
        documents: "src/graphql/**/*.graphql"
        generates:
        src/generated/graphql.tsx:
            plugins:
            - "typescript"
            - "typescript-operations"
            - "typescript-urql"

    c. (https://graphql-code-generator.com/docs/generated-config/typescript-urql/) Add to frontend devDependencies:
        "@graphql-codegen/typescript-urql": "^2.0.2",

    d. Create `./frontend/src/graphql/mutations/register.graphql`:
    mutation Register($username: String!, $password: String!) {
        register(input: { username: $username, password: $password }) {
            errors {
                field
                message
            }
            user {
                id
                username
            }
        }
    }

    e. Run new 'gen' script, this will create ./frontend/src/generated/graphql.tsx
        $ yarn gen

    f. The generated file above will contain our mutation and query hooks, which we can use via import, now. Our new pages/register.tsx is as follows:
    import React from "react";
    import { Formik, Form } from "formik";
    import {
    Box,
    Button,
    FormControl,
    FormErrorMessage,
    FormLabel,
    Input,
    } from "@chakra-ui/core";
    import { Wrapper } from "../components/Wrapper";
    import { InputField } from "../components/InputField";
    import { useRegisterMutation } from "../generated/graphql";

    interface registerProps {}

    const Register: React.FC<registerProps> = ({}) => {

    const [{ data, error }, register] = useRegisterMutation();

    return (
        <Wrapper variant="small">
        <Formik
            initialValues={{ username: "", password: "" }}
            onSubmit={async (values, {setErrors}) => {
                console.log(values);
                //return promise to end spinner on resolve
                const response = await register(values);
            }}
        >
            {({ isSubmitting }) => (
            <Form>
                <InputField
                label="Username"
                placeholder="username"
                name="username"
                />
                <Box mt={4}>
                <InputField
                    label="Password"
                    placeholder="password"
                    name="password"
                    type="password"
                />
                </Box>
                <Button
                mt={4}
                isLoading={isSubmitting}
                type="submit"
                variantColor="teal"
                >
                Submit
                </Button>
            </Form>
            )}
        </Formik>
        </Wrapper>
    );
    };

    export default Register;

    Notice now the type of our register mutation is now RegisterMutation, instead of something more general, which is what we want.

    g. Define custom array-to-dictionary utils function, to facilitate receiving errors from the backend and settng them on the frontend in accordance with Formik
    ./src/utils/toErrorMap.ts
    import { FieldError } from "../generated/graphql";
    

    export const ErrorToMap = (errors: FieldError[]) => {
        const errorMap: Record<string, string> = {};
        errors.forEach(({ field, message }) => {
            errorMap[field] = message;
        });
        return errorMap;
    };

    h. Modify ./src/pages/register Formik:
    import React from "react";
    import { Formik, Form } from "formik";
    import {
        Box,
        Button,
        FormControl,
        FormErrorMessage,
        FormLabel,
        Input,
    } from "@chakra-ui/core";
    import { Wrapper } from "../components/Wrapper";
    import { InputField } from "../components/InputField";
    import { useRegisterMutation } from "../generated/graphql";
    import { toErrorMap } from "../utils/toErrorMap";
    import { useRouter } from 'next/router'

    interface registerProps {}

    const Register: React.FC<registerProps> = ({}) => {
        const [{ data, error }, register] = useRegisterMutation();
        const router = useRouter();

        return (
            <Wrapper variant="small">
                <Formik
                    initialValues={{ username: "", password: "" }}
                    onSubmit={async (values, { setErrors }) => {
                        console.log(values);
                        //return promise to end spinner on resolve
                        const response = await register(values);
                        if (response.data?.register.errors) {
                            setErrors(toErrorMap(response.data.register.errors));
                        }
                        else if (response.data?.register.user){
                            router.push('/')
                        }
                    }}
                >
                    {({ isSubmitting }) => (
                    <Form>
                        <InputField
                        label="Username"
                        placeholder="username"
                        name="username"
                        />
                        <Box mt={4}>
                        <InputField
                            label="Password"
                            placeholder="password"
                            name="password"
                            type="password"
                        />
                        </Box>
                        <Button
                        mt={4}
                        isLoading={isSubmitting}
                        type="submit"
                        variantColor="teal"
                        >
                        Submit
                        </Button>
                    </Form>
                    )}
                </Formik>
            </Wrapper>
        );
    };

    export default Register;

8. Fix error "ValidationError: You cannot call em.flush() from inside lifecycle hook handlers" via QueryBuilder, instead of calling em.clear(). We have new user mutation resolver:
    //backend/src/resolvers/user.ts
    import { EntityManager } from "@mikro-orm/postgresql";
    //...
    @Mutation(() => UserResponse)
    async register(
        @Ctx() { em, req }: MyContext,
        @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
    ): Promise<UserResponse> {
        if (input.username.length <= 2) {
        return {
            errors: [
            {
                field: "username",
                message: "Length of provided username must be greater than 2.",
            },
            ],
        };
        }
        if (input.password.length <= 3) {
        return {
            errors: [
            {
                field: "password",
                message: "Length of provided password must be greater than 3.",
            },
            ],
        };
        }
        const hashedPassword = await argon2.hash(input.password);

        try {
        const [user] = await (em as EntityManager)
            .createQueryBuilder(User)
            .getKnexQuery()
            .insert({
            username: input.username,
            password: hashedPassword,
            created_at: new Date(),
            updated_at: new Date(),
            })
            .returning("*");

        //Store user ID on session
        //This will add a cookie on the session
        //Keep the user logged in
        req.session.userId = user.id;

        return { user };
        } catch (err) {
        console.log("message", err.message);
        if (err.code === "23505" || err.detail.includes("already exists")) {
            em.clear();
            //duplicate username error
            return {
            errors: [
                {
                message: "This username already exists",
                field: "username",
                },
            ],
            };
        }
        return {
            errors: [
            {
                message: "Something went wrong",
                field: "Unknown",
            },
            ],
        };
        }
    }

9. Login page
    a. Generate custom useLoginMutation hook from graphQL definition. Create src/graphql/mutations/login.graphql:
    mutation Login($username: String!, $password: String!) {
        login(input: { username: $username, password: $password }) {
            errors {
                field
                message
            }
            user {
                id
                username
            }
        }
    }

    b. Frontend page (basically identical to register, with some slight alterations)
    import React from "react";
    import { Formik, Form } from "formik";
    import { Box, Button } from "@chakra-ui/core";
    import { Wrapper } from "../components/Wrapper";
    import { InputField } from "../components/InputField";
    import { useLoginMutation } from "../generated/graphql";
    import { toErrorMap } from "../utils/toErrorMap";

    import { useRouter } from "next/router";

    interface registerProps {}

    const Login: React.FC<registerProps> = ({}) => {
    const [, login] = useLoginMutation();
    const router = useRouter();

    return (
        <Wrapper variant="small">
        <h1>Login page</h1>
        <Formik
            initialValues={{ username: "", password: "" }}
            onSubmit={async (values, { setErrors }) => {
            console.log(values);
            //return promise to end spinner on resolve
            const response = await login(values);
            if (response.data?.login.errors) {
                setErrors(toErrorMap(response.data.login.errors));
            } else if (response.data?.login.user) {
                //Redirect the user on successful registration
                router.push("/");
            }
            }}
        >
            {({ isSubmitting }) => (
            <Form>
                <InputField
                label="Username"
                placeholder="username"
                name="username"
                />
                <Box mt={4}>
                <InputField
                    label="Password"
                    placeholder="password"
                    name="password"
                    type="password"
                />
                </Box>
                <Button
                mt={4}
                isLoading={isSubmitting}
                type="submit"
                variantColor="teal"
                >
                Submit
                </Button>
            </Form>
            )}
        </Formik>
        </Wrapper>
    );
    };

    export default Login;

10. Navbar component
    a. First thing we want is to know who is the user currently signed in, to say "Welcome, [current user]". So let's define a 'me' UserResolver query, over in our backend, at ./src/resolvers/user, as follows:
        /**
        * Return the user associated with the id on the current session.
        */
        @Query(() => User, { nullable: true })
        async me(@Ctx() { req, em }: MyContext) {
            if (!req.session.userId) {
                return null;
            }
            const user = await em.findOne(User, { id: req.session.userId });
            return user;
        }
        Recall that in login and register, we set the id of the currently logged in user on the session on success. This operation, then, is an access to that user id, and we return the relevant user.
    b. Next, define the GraphQL 'me' query, in frontend/src/graphql/queries/me.graphql, as follows:
        query Me {
            me {
                id
                username
                //other user properties
            }
        }

    c. In the frontend, execute our `gen` script, to generate the requisite custom hook, for use on our frontend component. We have
        //package.json
        "gen": "graphql-codegen --config codegen.yml"
    and so
        $ yarn gen

    d. Define Navbar component, and access current user data via custom hook created by our above `gen` script. Recall that the custom hook's definition will be found in frontend/src/generated/graphql.tsx
    //frontend/src/components/NavBar
        import { Box, Flex, Link } from "@chakra-ui/core";
        import React from "react";
        import NextLink from "next/link";

        import { useMeQuery } from "../generated/graphql";

        interface NavBarProps {}

        export const NavBar: React.FC<NavBarProps> = ({}) => {
            const [{ data }] = useMeQuery();

            return (
                <Flex bg="tomato" p={4}>
                {!!data?.me?.username && (
                    <Box>
                    <h1>Welcome, {data?.me?.username}</h1>
                    </Box>
                )}
                <Box ml={"auto"}>
                    <NextLink href="login">
                    <Link mr={2}>Login</Link>
                    </NextLink>
                    <NextLink href="register">
                    <Link>Register</Link>
                    </NextLink>
                </Box>
                </Flex>
            );
        };
    Note that if we delete our session cookie, qid, which is what we use to see whether or not we're signed in (effectively simulating a logout), everything works as expected. However, if we start our app logged out and log in, our navbar doesn't update properly to reflect that. This is because URQL uses caching, and we need to update the cache.

11. Update set up and update URQL cache (https://formidable.com/open-source/urql/docs/graphcache/#installation-and-setup)
    a. Add to frontend dependencies
        "@urql/exchange-graphcache": "^3.1.4",
    b. Add exchanges to frontend URQL client, in frontend/src/pages/_app.tsx
        import { ThemeProvider, CSSReset } from "@chakra-ui/core";

        import theme from "../theme";

        import { createClient, dedupExchange, fetchExchange, Provider } from "urql";
        import { cacheExchange } from "@urql/exchange-graphcache";

        const client = createClient({
            url: "http://localhost:4000/graphql",
            fetchOptions: {
                credentials: "include",
            },
            exchanges: [dedupExchange, cacheExchange({}), fetchExchange],
        });

        function MyApp({ Component, pageProps }: any) {
            return (
                <Provider value={client}>
                <ThemeProvider theme={theme}>
                    <CSSReset />
                    <Component {...pageProps} />
                </ThemeProvider>
                </Provider>
            );
        }

        export default MyApp;

    c. Implement function to properly type our custom update and implement graphcache custom update (https://formidable.com/open-source/urql/docs/graphcache/custom-updates/#data-updates)

    // /frontend/src/pages/_app.tsx
    import { ThemeProvider, CSSReset } from "@chakra-ui/core";

    import theme from "../theme";

    import { createClient, dedupExchange, fetchExchange, Provider } from "urql";
    import { cacheExchange, QueryInput, Cache } from "@urql/exchange-graphcache";
    import {
    LoginMutation,
    MeDocument,
    MeQuery,
    RegisterMutation,
    } from "../generated/graphql";

    function betterUpdateQuery<Result, Query>(
        cache: Cache,
        queryInput: QueryInput,
        result: any,
        func: (r: Result, q: Query) => Query
    ) {
        return cache.updateQuery(
            queryInput,
            (data) => func(result, data as any) as any
        );
    }

    const client = createClient({
        url: "http://localhost:4000/graphql",
        fetchOptions: {
            credentials: "include",
        },
        exchanges: [
            dedupExchange,
            cacheExchange({
            updates: {
                Mutation: {
                login: (result, args, cache, info) => {
                    betterUpdateQuery<LoginMutation, MeQuery>(
                    cache,
                    { query: MeDocument },
                    result,
                    (newQueryResult, lastQueryResult) => {
                        if (newQueryResult.login.errors) {
                        return lastQueryResult;
                        }
                        return {
                        me: newQueryResult.login.user,
                        };
                    }
                    );
                },
                register: (result, args, cache, info) => {
                    betterUpdateQuery<RegisterMutation, MeQuery>(
                    cache,
                    { query: MeDocument },
                    result,
                    (newQueryResult, lastQueryResult) => {
                        if (newQueryResult.register.errors) {
                        return lastQueryResult;
                        }
                        return {
                        me: newQueryResult.register.user,
                        };
                    }
                    );
                },
                },
            },
            }),
            fetchExchange,
        ],
    });

    function MyApp({ Component, pageProps }: any) {
        return (
            <Provider value={client}>
            <ThemeProvider theme={theme}>
                <CSSReset />
                <Component {...pageProps} />
            </ThemeProvider>
            </Provider>
        );
    }

    export default MyApp;


12. Implement RegularUser fragment to avoid re-specifying user properties, irrespective of User definition.
    a. Create frontend/src/graphql/fragments/RegularUser.graphql:
    // frontend/src/graphql/fragments/RegularUser.graphql
    fragment RegularUser on User {
        id
        username
    }
    b. Replace any relevant mutation returns. For example, for our `me` query, instead of 
    // frontend/src/graphql/queries/me.graphql
    query Me {
        me {
            id
            username
        }
    }
    We can instead just have 
    // frontend/src/graphql/queries/me.graphql
    query Me {
        me {
            ...RegularUser
        }
    }
    And this way, it doesn't matter if we add new data fields to our User data type, we're stil golden.


13. Implement logout.
    a. Define new user mutation in backend.
        i. Remove user id from req
        ii. Test query on localhost:4000/graphql, at need.
    b. Define GraphQL mutation in frontend.
    c. Define new cacheExchange to update the cached result of the 'me' query.
    d. `yarn gen`, to create custom hooks
    e. Use custom hooks in the frontend (for instance, on our NavBar component)

14. Setting up Server-side rendering with URQL and GraphQL (https://formidable.com/open-source/urql/docs/advanced/server-side-rendering/#nextjs)
    a. install to dependencies
        "react-is": "^16.13.1",
        "next-urql": "^2.0.0",
        "isomorphic-unfetch": "^3.1.0",
    b. create ./frontend/src/utils/createUrqlClient.ts 
    c. Refactor:
        - betterUpdateQuery, createUrqlClient -> utils
        - frontend/src/pages/_app.tsx:
            import { CSSReset, ThemeProvider } from "@chakra-ui/core";
            import theme from "../theme";

            function MyApp({ Component, pageProps }: any) {
                return (
                    <ThemeProvider theme={theme}>
                    <CSSReset />
                    <Component {...pageProps} />
                    </ThemeProvider>
                );
            }

            export default MyApp;
    d. Wrap pages with our URQL client, specify SSR where appropriate
        //frontend/src/pages/index.tsx        
        import React from "react";
        import { withUrqlClient } from "next-urql";
        import { NavBar } from "../components/NavBar";
        import { createUrqlClient } from "../utils/createUrqlClient";

        const Index = () => (
            <>
                <NavBar />
                <h1>Hi!</h1>
            </>
        );

        export default withUrqlClient(createUrqlClient, {ssr: true})(Index);

15. Setting up forgot password (http://nodemailer.com/about/)
    a. add: 
        to backend dependencies:
            "nodemailer": "^6.4.13",
        to backend devDependencies
            "@types/nodemailer": "^6.4.0",    
    b. create backend/src/util/sendEmail.ts, copied mostly from nodemailer docs
        import nodemailer from "nodemailer";

        // async..await is not allowed in global scope, must use a wrapper
        export async function sendEmail(to: string, text: string) {
            // Generate test SMTP service account from ethereal.email
            // Only needed if you don't have a real mail account for testing
            let testAccount = await nodemailer.createTestAccount();
            console.log("testAccount", testAccount);

            // create reusable transporter object using the default SMTP transport
            let transporter = nodemailer.createTransport({
                host: "smtp.ethereal.email",
                port: 587,
                secure: false, // true for 465, false for other ports
                auth: {
                    user: testAccount.user, // generated ethereal user
                    pass: testAccount.pass, // generated ethereal password
                },
            });

            // send mail with defined transport object
            let info = await transporter.sendMail({
                from: '"Fred Foo 👻" <foo@example.com>', // sender address
                to, // list of receivers
                subject: "Hello ✔", // Subject line
                text, // plain text body
            });

            console.log("Message sent: %s", info.messageId);
            // Message sent: <b658f8ca-6296-ccf4-8306-87d57a0b4321@example.com>

            // Preview only available when sending through an Ethereal account
            console.log("Preview URL: %s", nodemailer.getTestMessageUrl(info));
            // Preview URL: https://ethereal.email/message/WaQKMgKddxQDoou...
        }
    c. Execute the sendEmail function once in our backend index, copy the credentials, and then remove the lines of code creating the account on each execution.
        1. Add the sendEmail invocation to backend/src/index:
            // backend/src/index.ts
            //...other imports
            import { sendEmail } from "./utils/sendEmail";

            const main = async () => {
                sendEmail("bob@bob.com", "Hello there!");
                //...other things
            }
        You'll get something like the following as output to the console:
            Server listening on port 4000
            testAccount {
                user: 'qwxjb2opgka7rxid@ethereal.email',
                pass: 'Hpsny21p9VqW8daKBR',
                smtp: { host: 'smtp.ethereal.email', port: 587, secure: false },
                imap: { host: 'imap.ethereal.email', port: 993, secure: true },
                pop3: { host: 'pop3.ethereal.email', port: 995, secure: true },
                web: 'https://ethereal.email'
            }
            Message sent: <a512ed48-f665-e63f-606e-f9732feebc8a@example.com>
            Preview URL: https://ethereal.email/message/X4YBIdiVZjXHiPCDX4YBIz.pZXd6tXYtAAAAAQ9S-YAE5wn4lm9QPwMt8cI

        2. Copy-paste the `user` and `pass` fields into the sendEmail function, as follows. Also, uncomment the first lines of code, in which a new nodemailer account is created.
            import nodemailer from "nodemailer";

            // async..await is not allowed in global scope, must use a wrapper
            export async function sendEmail(to: string, text: string) {
                // Generate test SMTP service account from ethereal.email
                // Only needed if you don't have a real mail account for testing
                //   let testAccount = await nodemailer.createTestAccount();
                //   console.log("testAccount", testAccount);

                // create reusable transporter object using the default SMTP transport
                let transporter = nodemailer.createTransport({
                    host: "smtp.ethereal.email",
                    port: 587,
                    secure: false, // true for 465, false for other ports
                    auth: {
                        user: "qwxjb2opgka7rxid@ethereal.email", // generated ethereal user
                        pass: "Hpsny21p9VqW8daKBR", // generated ethereal password
                    },
                });

                // send mail with defined transport object
                let info = await transporter.sendMail({
                    from: '"Fred Foo 👻" <foo@example.com>', // sender address
                    to, // list of receivers
                    subject: "Hello ✔", // Subject line
                    text, // plain text body
                });

                console.log("Message sent: %s", info.messageId);
                // Message sent: <b658f8ca-6296-ccf4-8306-87d57a0b4321@example.com>

                // Preview only available when sending through an Ethereal account
                console.log("Preview URL: %s", nodemailer.getTestMessageUrl(info));
                // Preview URL: https://ethereal.email/message/WaQKMgKddxQDoou...
            }

        3. Add `email` field to User entity, and create new migration.
            //new backend/src/entities/User.ts:
            import { Entity, PrimaryKey, Property } from "@mikro-orm/core";
            import { Field, Int, ObjectType } from "type-graphql";

            @ObjectType()
            @Entity()
            export class User {
                @Field(() => Int)
                @PrimaryKey()
                id!: number;

                @Field(() => String)
                @Property({ type: "date" })
                createdAt = new Date();

                @Field(() => String)
                @Property({ type: "date", onUpdate: () => new Date() })
                updatedAt = new Date();

                @Field(() => String)
                @Property({ type: "text", unique: true })
                username!: string;

                @Field(() => String)
                @Property({ type: "text", unique: true })
                email!: string;

                @Property({ type: "text" })
                password!: string;
            }

            //in bckend terminal, 
            $ yarn create:migration

            Verify the successful new migration by checking the backend/src/migrations folder.
            You may get an error after this, if you have any newly created users with no email (or rather with an email field set to null), you may need to wipe your table. We do this with an em.nativeDelete:

            // backend/src/index
            // ...other imports
            import { User } from "./entities/User";

            const main = async () => {
                sendEmail("bob@bob.com", "<a>Hello there!</a>");

                //Connect to MikroORM
                const orm = await MikroORM.init(microConfig);
                // Delete everything in User table
                // await orm.em.nativeDelete(User, {})

                // Find all entries in the User table to verify successful deletion
                // const users = await orm.em.find(User, {});
                // console.log("users", users);
                
                //... other main things
            }
            By the way, we can also solve the issue of having entries with a null value for the email by adding nullable: true on the User entity, for the email field.

        4. Modify past user resolvers to take email into account, make changes to frontend register form.
        5. Add forgotPassword Mutation resolver to user resolvers.
            i. Search for user from email, if any are found, send email with link to `change-password` page, with a generated token.
            ii. Install to backend dependencies
                "ioredis": "^4.17.3",
                "uuid": "^8.3.1"
               and to devDependencies
                "@types/ioredis": "^4.17.5",
                "@types/uuid": "^8.3.0",
            iii. Fix redis init in backend/src/index
            import "reflect-metadata";
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";
            import { ApolloServer } from "apollo-server-express";
            import { buildSchema } from "type-graphql";

            import { COOKIE_NAME, __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            import { HelloResolver } from "./resolvers/hello";
            import { PostResolver } from "./resolvers/post";
            import { UserResolver } from "./resolvers/user";

            import connectRedis from "connect-redis";
            import Redis from "ioredis";
            import session from "express-session";

            import cors from "cors";
            import { sendEmail } from "./utils/sendEmail";
            import { User } from "./entities/User";

            const main = async () => {
            sendEmail("bob@bob.com", "<a>Hello there!</a>");

            //Connect to MikroORM
            const orm = await MikroORM.init(microConfig);
            // Delete everything in User table
            // await orm.em.nativeDelete(User, {})

            // Find all entries in the User table to verify successful deletion
            const users = await orm.em.find(User, {});
            console.log("users", users);

            //Run migrations
            await orm.getMigrator().up();

            const PORT = 4000;
            const app = express();

            const RedisStore = connectRedis(session);
            //initialize redis client
            const redis = new Redis();

            app.use(
                cors({
                origin: "http://localhost:3000",
                credentials: true,
                })
            );

            app.use(
                session({
                name: COOKIE_NAME,
                store: new RedisStore({ client: redis, disableTouch: true }),
                cookie: {
                    //No access to cookie from frontend
                    httpOnly: true,
                    //Set cookie lifespan to 10 years
                    maxAge: 1000 * 60 * 60 * 24 * 365 * 10,
                    //Only work for https
                    secure: __prod__,
                    sameSite: "lax", //csrf
                },
                saveUninitialized: false,
                secret: "hbfwelmxlzwjdcdllw",
                resave: false,
                })
            );

            const apolloServer = new ApolloServer({
                schema: await buildSchema({
                resolvers: [HelloResolver, PostResolver, UserResolver],
                validate: false,
                }),
                context: ({ req, res }) => ({ em: orm.em, req, res, redis }),
            });

            apolloServer.applyMiddleware({
                app,
                cors: false,
            });

            app.listen(PORT, () => {
                console.log(`Server listening on port ${PORT}`);
            });
            };

            main().catch((e) => {
            console.log(e);
            });


            iv. include redis in backend/src/types
            import { EntityManager, IDatabaseDriver, Connection } from "@mikro-orm/core";
            import { Request, Response } from "express";
            import { Redis } from "ioredis";

            export type MyContext = {
                em: EntityManager<any> & EntityManager<IDatabaseDriver<Connection>>;
                req: Request & { session: Express.Session };
                res: Response;
                redis: Redis;
            };

            v. Remove `redis` from backend packages

            vi. Add the following resolvers to UserResolver:'
            
            //forgotPassword
            @Mutation(() => Boolean)
            async forgotPassword(
                @Arg("email", () => String) email: string,
                @Ctx() { em, redis }: MyContext
            ) {
                const user = await em.findOne(User, { email });
                if (!user) return false;

                const token = v4();
                const key = FORGET_PASSWORD_PREFIX + token;
                await redis.set(key, user.id, "ex", 1000 * 60 * 60 * 24 * 3); //expire in three days

                const htmlText = `<a href="http://localhost:3000/change-password/${token}">Change password</a>`;
                await sendEmail("bob@bob.com", htmlText);

                return true;
            }
            The above can now be tested from localhost:4000/graphql. There should be a console log abut the message's success, and you can follow the link to see the actual message, which in turn will enable you to click the link and get to the change-password page, along wth a generated token.

            // changePassword   

            @Mutation(() => UserResponse)
            async changePassword(
                @Arg("token", () => String) token: string,
                @Arg("newPassword", () => String) newPassword: string,
                @Ctx() { em, redis, req }: MyContext
            ): Promise<UserResponse> {
                if (newPassword.length <= 3) {
                return {
                    errors: [
                    {
                        field: "newPassword",
                        message: "Length of provided password must be greater than 3.",
                    },
                    ],
                };
                }

                const key = FORGET_PASSWORD_PREFIX + token;
                const id = await redis.get(key);
                if (!id) {
                return {
                    errors: [
                    {
                        field: "token",
                        message: "Token expired.",
                    },
                    ],
                };
                }
                const user = await em.findOne(User, { id: parseInt(id) });
                if (!user) {
                return {
                    errors: [{ field: "user", message: "No user found for provided id" }],
                };
                }

                //Change the user's password
                user.password = await argon2.hash(newPassword);
                await em.persistAndFlush(user);

                //Destroy token on password reset
                await redis.del(key);

                //Login the user after password change
                req.session.userId = user.id;

                return { user };
            } 

            So the flow in the above is to toggle the forgotPassword resolver, which sends an email to the user, they click the link in the email, get taken to the change-password page, along with a token. This token is single-use and valid for at most three days. After the user changes their password, their token is invalidated and they are taken to home page.

        6. Define frontend graphql files, frontend/src/graphql/mutations:
        - changePassword.graphql
        mutation ChangePassword($newPassword: String!, $token: String!) {
            changePassword(newPassword: $newPassword, token: $token) {
                user {
                id
                username
                }
                errors {
                field
                message
                }
            }
        }

        - forgotPassword.graphql
        mutation ForgotPassword($email: String!) {
            forgotPassword(email: $email)
        }

        Do a `yarn gen` to generate our custom hooks.

        7. Define frontend forgot-password.tsx
            import React from "react";
            import { createUrqlClient } from "../utils/createUrqlClient";
            import { withUrqlClient } from "next-urql";
            import { Box, Button } from "@chakra-ui/core";
            import { Formik, Form } from "formik";
            import { InputField } from "../components/InputField";
            import { Wrapper } from "../components/Wrapper";

            import { useForgotPasswordMutation } from "../generated/graphql";
            import { useState } from "react";

            const ForgotPassword: React.FC<{}> = ({}) => {
                const [isComplete, setIsComplete] = useState(false);
                const [, forgotPassword] = useForgotPasswordMutation();
                return (
                    <Wrapper variant="small">
                    <Formik
                        initialValues={{ email: "" }}
                        onSubmit={async (values, { setErrors }) => {
                        //return promise to end spinner on resolve
                        const response = await forgotPassword({ email: values.email });
                        console.log("response", response);

                        setIsComplete(true);
                        }}
                    >
                        {({ isSubmitting }) =>
                        isComplete ? (
                            <Box>Email sent</Box>
                        ) : (
                            <Form>
                            <InputField
                                label="Email"
                                placeholder="email"
                                name="email"
                                type="email"
                            />
                            <Button
                                mt={1}
                                isLoading={isSubmitting}
                                type="submit"
                                variantColor="teal"
                            >
                                Send reset password email
                            </Button>
                            </Form>
                        )
                        }
                    </Formik>
                    </Wrapper>
                );
            };

        export default withUrqlClient(createUrqlClient, { ssr: true })(ForgotPassword);

        8. Define frontend page change-password/[token].tsx

        import { Box, Button, Link as ChakraLink } from "@chakra-ui/core";
        import { Formik, Form } from "formik";
        import { NextPage } from "next";
        import React, { useState } from "react";
        import { InputField } from "../../components/InputField";
        import { Wrapper } from "../../components/Wrapper";
        import { useRouter } from "next/router";

        import { withUrqlClient } from "next-urql";
        import { useChangePasswordMutation } from "../../generated/graphql";
        import { toErrorMap } from "../../utils/toErrorMap";
        import { createUrqlClient } from "../../utils/createUrqlClient";
        import NextLink from "next/link";

        const ChangePassword: NextPage<{ token: string }> = ({ token }) => {
            const [tokenError, setTokenError] = useState("");
            const [, changePassword] = useChangePasswordMutation();
            const router = useRouter();
            console.log("tokenError", tokenError);
            return (
                <Wrapper variant="small">
                <Formik
                    initialValues={{ newPassword: "" }}
                    onSubmit={async (values, { setErrors }) => {
                        //return promise to end spinner on resolve
                        const response = await changePassword({
                            ...values,
                            token,
                        });
                        console.log("response", response);

                        if (response.data?.changePassword.errors) {
                            const errorMap = toErrorMap(response.data?.changePassword.errors);
                            if ("token" in errorMap) {
                                const errMsg = errorMap.token;
                                setTokenError(errMsg);
                            }
                            setErrors(errorMap);
                        } else if (response.data?.changePassword.user) {
                            setTokenError("");
                            //Redirect the user to home on successful password change
                            router.push("/");
                        }
                    }}
                >
                    {({ isSubmitting }) => (
                    <Form>
                        <Box mt={4}>
                        <InputField
                            label="New password"
                            placeholder="new password"
                            name="newPassword"
                            type="password"
                        />
                        </Box>
                        {tokenError && (
                            <Box>
                                <Box style={{ color: "red" }}>{tokenError}</Box>
                                <NextLink href="/forgot-password">
                                <ChakraLink>Forget password again</ChakraLink>
                                </NextLink>
                            </Box>
                        )}
                        <Button
                            mt={4}
                            isLoading={isSubmitting}
                            type="submit"
                            variantColor="teal"
                        >
                        Change password
                        </Button>
                    </Form>
                    )}
                </Formik>
                </Wrapper>
            );
        };

        ChangePassword.getInitialProps = ({ query }) => ({
            token: query.token as string,
        });

        export default withUrqlClient(createUrqlClient, { ssr: true })(ChangePassword);

16. Ripping out MikroORM in favor of typeorm (docs @ https://typeorm.io/#/).
    a. to backend dependencies add
        "typeorm": "^0.2.28",
    b. Create typeorm connection in backend/src/index.
        await createConnection({
            type: "postgres",
            database: "lireddit2",
            username: "postgres",
            password: "postgres",
            logging: true,
            //automatically perform migrations
            synchronize: true,
            entities: [User, Post],
        });

        //(OPTIONAL) See all users in db
        const users = await User.find();
        console.log("Users", users);

    c. Add appropriate typeorm decorators to entity classes, and make all entity classes extend BaseEntity (IMPORTANT).

    //entities/User
    import {
        BaseEntity,
        Column,
        CreateDateColumn,
        Entity,
        PrimaryGeneratedColumn,
        UpdateDateColumn,
    } from "typeorm";
    import { Field, Int, ObjectType } from "type-graphql";

    @ObjectType()
    @Entity()
    export class User extends BaseEntity {
        @Field(() => Int)
        @PrimaryGeneratedColumn()
        id!: number;

        @Field(() => String)
        @CreateDateColumn()
        createdAt: Date;

        @Field(() => String)
        @UpdateDateColumn()
        updatedAt: Date;

        @Field(() => String)
        @Column({ unique: true })
        username!: string;

        @Field(() => String)
        @Column({ unique: true })
        email!: string;

        @Column()
        password!: string;
    }

    //entities/Post
    import {
        Entity,
        PrimaryGeneratedColumn,
        Column,
        CreateDateColumn,
        UpdateDateColumn,
        BaseEntity,
    } from "typeorm";
    import { Field, Int, ObjectType } from "type-graphql";

    @ObjectType()
    @Entity()
    export class Post extends BaseEntity {
        @Field(() => Int)
        @PrimaryGeneratedColumn()
        id!: number;

        @Field(() => String)
        @CreateDateColumn()
        createdAt: Date;

        @Field(() => String)
        @UpdateDateColumn()
        updatedAt: Date;

        @Field(() => String)
        @Column()
        title!: string;
    }

    d. Make changes to types file, where context is defined.
    //backend/src/types.ts
        import { Request, Response } from "express";
        import { Redis } from "ioredis";

        export type MyContext = {
            req: Request & { session: Express.Session };
            res: Response;
            redis: Redis;
        };

    e. Remove `em` from all resolvers and reimplement them using typeorm syntax.
    //For instance, in backend/src/resolvers/user:
    @Mutation(() => Boolean)
    async forgotPassword(
        @Arg("email", () => String) email: string,
        @Ctx() { redis }: MyContext
    ) {
        const user = await User.findOne({ where: { email } });
        if (!user) return false;

        const token = v4();
        const key = FORGET_PASSWORD_PREFIX + token;
        await redis.set(key, user.id, "ex", 1000 * 60 * 60 * 24 * 3); //expire in three days

        const htmlText = `<a href="http://localhost:3000/change-password/${token}">Change password</a>`;
        await sendEmail(email, htmlText);

        return true;
    }

    f. Ensure there is no trace of `mikro` anywhere in our project, to complete our transition to typeorm.

    g. Create a new db via `createdb [dbname]` (we're going with the classic 'lireddit2')

    h. Test our resolvers via localhost:4000/graphql

    i. remove all mikro-orm devDependencies
        "@mikro-orm/cli": "^4.0.7",
        "@mikro-orm/core": "^4.0.7",
        "@mikro-orm/migrations": "^4.0.7",
        "@mikro-orm/postgresql": "^4.0.7",

    j. remove from package.json our mikroORM migrations script
        //DELETE ME    
        "create:migration": "mikro-orm migration:create"     

    k. Delete mikro-orm.config.ts

17. Creating a many-to-one relationship on our users, to keep track of their posts (docs: https://typeorm.io/#/many-to-one-one-to-many-relations)

18. An example of define middleware to be used on one of our resolvers for, for example, authentication:
    a. Define the middleware
    //backend/src/middlewares/isAuth.ts
        import { MyContext } from "src/types";
        import { MiddlewareFn } from "type-graphql";

        export const isAuth: MiddlewareFn<MyContext> = ({ context }, next) => {
            if (!context.req.session.userId) {
                throw new Error("Not authenticated");
            }
            return next();
        };

    b. Add the UseMiddleware decorator to the concerned resolver:
    // backend/src/resolvers/post, as an example
        @Mutation(() => Post)
        @UseMiddleware(isAuth) //Disable post functionality for users not signed in
        async createPost(
            @Ctx() { req }: MyContext,
            @Arg("input", () => PostInput) input: PostInput
        ): Promise<Post> {
            return Post.create({ ...input, creatorId: req.session.userId }).save();
        }

19. Create post
    a. Define createPost resolver (using our isAuth middleware, as defined above)
    b. Test the mutation on localhost:444/graphql
    c. Create the graphql mutation in frontend/src/graphql/mutations/createPost.graphql
    d. `yarn gen` to make us our custom hooks for use in frontend
    e. Create `create-post` page.
    f. Create global URQL error handler in `createUrqlClient`, using example from https://github.com/FormidableLabs/urql/issues/225
        1. define new errorExchange
        //frontend/src/utils/createUrqlClient
        const errorExchange: Exchange = ({ forward }) => (ops$) => {
            return pipe(
                forward(ops$),
                tap(({ error }) => {
                    if (error?.message.includes("not authenticated")) {
                        Router.replace("/login");
                    }
                })
            );
        };

        2. add new errorExchange to the list of exchanges.
        // frontend/src/utils/createUrqlClient
        export const createUrqlClient = (ssrExchange: any) => ({
            url: "http://localhost:4000/graphql",
            fetchOptions: {
                credentials: "include" as const,
            },
            exchanges: [
                ...some exchanges...
                errorExchange, 
                ssrExchange,
                fetchExchange,
            ]
        }    

20. Prevent the user from having their content lost on create-post page.
    a. Define `useIsAuth` hook. Its function? To redirect the user on insufficient access credentials.
    //frontend/src/utils/useIsAuth
        import { useEffect } from "react";
        import { useMeQuery } from "../generated/graphql";
        import { useRouter } from "next/router";

        export const useIsAuth = () => {
            const router = useRouter();
            const [{ data, fetching }] = useMeQuery();
            //Redirect user to login on page access without user credentials
            useEffect(() => {
                if (!data?.me && !fetching) {
                    router.push("/login");
                }
            }, [data, fetching]);
        };
    b. Add to create-post page    

21. Paginate our posts
    a. Modify our posts resolver in backend (https://typeorm.io/#/select-query-builder)


How to wipe a db table using typeorm:
- in our connection config, set synchronize to `false`
- await [EntityName].delete({})

What does it give us to extend BaseEntity when we're defining our entities for use with typeorm? When we extend BaseEntity, it gives us access to some easy db ops for our data types, so for instance, we could say 

@ObjectType()
@Entity()
export class Post extends BaseEntity {
    //...
}
Now we can just say
    Post.insert({...})
directly!

Okay, NextJS fun-fact time.
- In nextJS, we can specify a page which is expected to receive some variables in the URL as follows: we define a new folder for the page name, with the variable names themselves enclosed in square brackets. So for instance, if we have a page called `change-password`, which is taking a parameter `token`, we have the following:
/pages
    /change-password
        /[token].tsx
    ...other pages  
The change-password page could have the following definition:
    // pages/change-password/[token].tsx
        import { NextPage } from "next";
        const ChangePassword: NextPage<{ token: string }> = ({ token }) => {
            return <div>token is {token}</div>;
        };

        ChangePassword.getInitialProps = ({ query }) => ({
        t   oken: query.token as string,
        });

        export default ChangePassword;


So what's the flow for a new feature?
1. Map out the frontend, see how we want our data
2. Make changes to the backend data:
    a. Do we need a new data type? If so...
        1. Create a new entity (backend/src/entities)
        2. Add the new entity to the list of imports in backend/src/mikro-orm.config.ts
        3. run command `yarn create:migration`, AKA
            // backend/package.json
            "create:migration": "mikro-orm migration:create"
    b. Do we need a new resolvers class for our new entity? If so...
        1. Create a new resolver class (backend/src/resolvers)
        2. Add the new resolver to the list of imports in backend/src/index.ts
    c. Do we need new resolvers?
        1. Add the new resolvers to our respective resolvers class file
        2. Test the resolvers on http://localhost:4000/graphql
        3. Create a graphql file in frontend/src/graphql/(mutations|queries|whatever) so that our `yarn gen` actually creates our custom hook creation
        4. Use the custom hooks in our components to fetch our data or make our modifications, as needed.
3. Change the frontend with respect to a new query result, as a result of a mutation. 
    a. Is there a cached query we want to refresh on completion of the given resolver? For instance, we want `logout` to affect all of our frontend displays.
        1. Add a new cacheExchange in frontend/src/pages/_app.tsx, to store any new query results we want cached.


When should we use server-side rendering?
1. We want our page's data to show up on a google search
    Why? Because if it's server-side rendered, then the client-side doesn't have anything to figure out, it's just served the finalized page, whereas a page that's not server-side rendering doesn't necessarily have its content persist after the client-side JS has its way with the page.    
2. We have some data we need to show on our page (record data, etc.). For instance, a login page doesn't need to be server-side rendered, because it's a static page. Static pages do not require SSR.

A note on using typescript to access deeply-nested data which may or may not be undefined:
If we make a fetch returning to us 
    if (response.data.register.errors){
        //do something
    }
for example, it would be possible for us to getg an error in the case where data returned as undefined. In the past we would have to handle this either by chaining ORs, or what-have-you. We can do this more neatly in typescript, with the following:    
    if (response.data?.register.errors){
            //do something
    }
This allows us to more succintly handle the case wherein data is undefined.    



Typescript-react code snippets:
https://gist.github.com/benawad/1e9dd01994f78489306fbfd6f7b01cd3#file-snippets-typescriptreact-json
Add the above to your typescriptreact.json file to have some sick new custom code snippets  


A note on what's happening with session.
When we do req.session.userId = user.id, we're storing the user's id on the session. Behind the scenes, any data that we store on our req is going to be stored on redis, and redis is a key-value store. After the data is stored on redis, a signed version of the key it's saved under is sent to the browser, and whenever the user makes a request, a copy of that key is sent to the server to test for authorization to access the requisite data. After the cookie is 

In which order does my express middleware run? In the same order as you add it onto our app.

How do I know which types I may need to install after installing new packages?
If the import is highlighted in red, hovering over it should tell us which types are missing.

We're using Connect-Redis for our redis. 
https://github.com/tj/connect-redis

"ValidationError: You cannot call em.flush() from inside lifecycle hook handlers"
If you find the GraphQL server becoming unresponsive following a failed entry because of a violated unique constraint, consider using em.clear().
Note: Ben Awad solves this himself later, by writing the SQL himself via QueryBuilder.
https://github.com/mikro-orm/mikro-orm/issues/696
Here is my use case:
    @Resolver()
    export class UserResolver {
    @Mutation(() => UserResponse)
    async register(
        @Ctx() { em }: MyContext,
        @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
    ): Promise<UserResponse> {
        const hashedPassword = await argon2.hash(input.password);
        const user = em.create(User, {
            username: input.username,
            password: hashedPassword,
        });
        try {
        await em.persistAndFlush(user);
        } catch (err) {
        console.log("message", err.message);
        if (err.code === "23505" || err.detail.includes("already exists")) {
            // *** Over here ***
            em.clear();
            
            //duplicate username error
            return {
            errors: [
                {
                message: "This username already exists",
                field: "username",
                },
            ],
            };
        }
        return {
            errors: [
            {
                message: "Something went wrong",
                field: "Unknown",
            },
            ],
        };
        }
        return { user };
    }

A note on creating ObjectType or InputType variables with a ?
@ObjectType()
class UserResponse {
  @Field()
  errors?: Error[];
  @Field(() => String)
  user?: User;
}
In the above, we initialize errors and user as undefined.

A note on why ObjectType vs InputType as class declarations.
ObjectTypes we return from our resolvers, whereas InputTypes we receive as arguments.    

What does it do for us to implement our HelloResolver in our src/index.ts schema definition? What this does for us is it defines a graphQL endpoint for our queries.


Before losing your mind on debugging:
Make sure your dist looks the way it should. It's possible that over the course of programming, it gets filled up with a lot of trash (or duplicates from slightly different files). The solution? Erase dist and re-run our `start` and `watch` script, to remake a fresh one.

A note on module not found from the resolvers:
Not sure why, but over in the resolver definitions, we need to need to specify the entity type via the '../entities/post' format, as opposed to the more general 'src/entities/post'. Not sure why.

A note on error TS2307: Cannot find module 'class-validator' or its corresponding type declarations.
For this you need to add 'class-validator' to dev dependencies.
Awad also shows us another way to solve this, by adding `"skipLibCheck": true` in tsconfig.json

A note on the purpose of our mikro-orm.config.ts:
We make this src/mikro-orm.config.ts in order to be able to access our custom data types from our MikroORM CLI.

A note on why not to use 'ts-node': 
- it's slow
- when we get to production, we don't use ts-node; we compile to JS and execute that. We elect not to use ts-node to be closer to the production environment, in dev
Our solution to ts-node?
- A 'watch' script executing typescript with the watch flag, to monitor file changes to src/index.ts; spits out a dist build (JS) on file change.
- A 'dev' script to execute 'nodemon' on our produced dist directory, coming from the watch script. To the difference of 'node', 'nodemon' will listen for changes made to our compiled dist file, resulting from our watch script.
Note that the two points above must be two scripts running in tandem. We can do this either in two separate terminal instances, or at once via 'concurrently' package.

A note on the difference between orm.em.create, orm.em.persistAndFlush and orm.em.nativeInsert:

A note on node `path` and `__dirname`
These variables come installed in node, and basically they help us ensure that we're running things from the right place, and we have access to the imports we need. __dirname is a pre-defined global variable whose value corresponds to the absolute path leading to the file it's called in (at run time, which is pertinent for us, because we're transpiling before running).

A note on migrations in MikroORM.
After running the $ npx mikro-orm migration:create, from https://mikro-orm.io/docs/migrations/#using-via-cli, we'll have a new migrations directory with the literal SQL generated by our data definitions in our entities. In the migrations, we can see the data types of all of our properties.



Tutorial reference: https://www.youtube.com/watch?v=I6ypD7qv3Z8&ab_channel=BenAwad

A note on text editors:
I don't give a fuck who you think you are, use VS Code.

A note on extensions:
To see extensions which are currently installed, you can enter into the searchbar command @installed.

VS Code extensions:
- Bracket Pair Colorizer 2 (0.2.0)
- Docker (1.6.0)
- GraphQL for VSCode (1.15.3)
- Prettier - Code formatter (5.7.1)
- Vim (1.17.1) - Disabled for now

How to enable auto-formatting on save for VS Code. 
You can achieve the same result by messing with your settings, which is fine, you can find the relevant config over on the Prettier - Code formatter docs, but you can also do the following, simply via the editor settings:
Code > Preferences > Settings > User. Search for "format", and check "format on save"

Backend init steps:
1. New package.json to backend root
2. Install packages 
    a. devDependencies:
        "@types/node": "^14.11.5",
        "concurrently": "^5.3.0",
        "nodemon": "^2.0.4",
        "ts-node": "^9.0.0",
        "typescript": "^4.0.3"
    b. dependencies:
        "@mikro-orm/cli": "^4.0.7",
        "@mikro-orm/core": "^4.0.7",
        "@mikro-orm/migrations": "^4.0.7",
        "@mikro-orm/postgresql": "^4.0.7",
        "pg": "^8.4.0"    

3. tsconfig.json to backend root
    $ npx tsconfig.json

4. Create the following src/index.ts to test the functionality of the scripts which follow:
//src/index.ts:
console.log('Hello world!');

5. New scripts to package.json (remove comments after copy-paste)
"scripts":[
    //Transpile ts to js, retranspile on file change
    "watch" : "tsc -w",
    //Compile generated js
    "start": "nodemon dist/index.js"
]    

6. Initialize db
    a. if needed, install postgresql 
        $ brew install postgresql
    b. Ensure successful install via 
        $ postgres -V
    c. Ensure existence of postgres default account with the following:
        1. $ psql postgres
        2. postgres=# \du
        3. (Optional) If now you DON'T see postgres account listed, exit and run the following:
            a. $ createuser -s postgres
                  
    d. (Optional) add db scripts to package.json, for instance:
        "pg-start": "brew services start postgresql",
        "pg-stop" : "brew services stop postgresql"

    e. (After starting postgresql instance via 'pg-start' script defined above) create new db.
        $ createdb [DB_NAME]

    d. Create a new entity, in accordance with mikro-orm docs: https://mikro-orm.io/docs/defining-entities/
    //entities/Post.ts:
    import { Entity, PrimaryKey, Property } from "@mikro-orm/core";

    @Entity()
    export class Post {
        @PrimaryKey()
        id!: number;

        @Property({ type: "date" })
        createdAt = new Date();

        @Property({ type: "date", onUpdate: () => new Date() })
        updatedAt = new Date();

        @Property({ type: "text" })
        title!: string;
    }


    e. Set up MikroORM CLI to allow for ops to db.
        i. Add to package.json (Source: https://mikro-orm.io/docs/installation#setting-up-the-commandline-tool):
        {
            "name": "your-app",
            "dependencies": { ... },
            "mikro-orm": {
                "useTsNode": true,
                "configPaths": [
                "./src/mikro-orm.config.ts",
                "./dist/mikro-orm.config.js"
                ]
            }
        }
        
        ii. Create 'src/mikro-orm.config.ts' with the following:
        //Source: https://mikro-orm.io/docs/migrations/#configuration
        import { MikroORM } from "@mikro-orm/core";
        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";

        import path from "path";

        export default {
            migrations: {
                path: path.join(__dirname, "./migrations"), // path to the folder with migrations
                pattern: /^[\w-]+\d+\.[tj]s$/, // regex pattern for the migration files (.js or .ts)
            },
            dbName: "lireddit",
            entities: [Post],
            type: "postgresql",
            debug: !__prod__,
        } as Parameters<typeof MikroORM.init>[0];

        iii. Have the following as src/index.ts
        //src/index.ts
        import { MikroORM } from "@mikro-orm/core";
        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";

        import microConfig from "./mikro-orm.config";

        const main = async () => {
            const orm = await MikroORM.init(microConfig);

            //Create a new Post (does not affect db)
            const post = orm.em.create(Post, { title: "My first post" });
            await orm.em.persistAndFlush(post);
            console.log("--------------SQL 2-------------------");
            await orm.em.persistAndFlush(post);
        };

        main().catch((e) => {
            console.log(e);
        });

        
        iv. Create MikroORM migration via CLI command 
        (Source: https://mikro-orm.io/docs/migrations/#using-via-cli)
            $ npx mikro-orm migration:create
        If running the above gives you the "role postgres doesn't exist" error (which means there's no defined postgres user), then see 5.c.3, '(Optional) If now you DON'T see postgres account listed, exit and run the following'.

        v. Delete `dist` folder, for now, to avoid problems later with duplicates.

        vi. Automate migration by including it in src/index.ts. Modify src/index.ts to the following. Test success with `start` and `watch` command chain.
        //src/index.ts
        import { MikroORM } from "@mikro-orm/core";

        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";
        import microConfig from "./mikro-orm.config";

        const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                //Create a new Post (does not affect db)
                const post = orm.em.create(Post, { title: "My first post" });
                await orm.em.persistAndFlush(post);
            };

            main().catch((e) => {
            console.log(e);
        });
    7. Initialize server
        a. Add to dependencies:
            "apollo-server-express": "^2.18.2",
            "express": "^4.17.1",
            "graphql": "^15.3.0",
            "type-graphql": "^1.0.0",
            "reflect-metadata": "^0.1.13"
        b. Add to devDependencies
            "@types/express": "^4.17.8",
        c. Test express works properly with the following:
            1. ensure src/index.ts matches:
            import "reflect-metadata";
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                const app = express();
                const PORT = 4000;

                app.get("/", (req, res) => {
                    res.send("Hello world from Express!");
                });

                app.listen(PORT, () => {
                    console.log(`Server listening on port ${PORT}`);
                });
            };

            main().catch((e) => {
                console.log(e);
            });

            2. Navigate to http://localhost:4000, you should receive "Hello world from Express!"
        d. Set up apollo-server-express
            i. Create HelloResolver class
            //src/resolvers/hello.ts  
            import { Query, Resolver } from "type-graphql";

            @Resolver()
            export class HelloResolver {
                @Query(() => String)
                hello() {
                    return "Hello world!";
                }
            }
            ii. Implement hello resolver in apollo-server graphql schema
            //src/index.ts
            import "reflect-metadata";
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";
            import { ApolloServer } from "apollo-server-express";
            import { buildSchema } from "type-graphql";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            import { HelloResolver } from "./resolvers/hello";

            const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                const PORT = 4000;
                const app = express();

                const apolloServer = new ApolloServer({
                    schema: await buildSchema({
                    resolvers: [HelloResolver],
                    validate: false,
                    }),
                });

                apolloServer.applyMiddleware({ app });

                app.listen(PORT, () => {
                    console.log(`Server listening on port ${PORT}`);
                });
            };

            main().catch((e) => {
                console.log(e);
            });
            iii. Verify successful graphQL endpoint by navigating to http://localhost:4000 and trying out the `hello` query. You should see as output 'Hello world'
        e. Combine apollo-server-express with MikroORM for some CRUD ops
            i. Modify Post entity to be a GraphQL type via @ObjectType declaration, specifying the return types of each field.
            //src/entities/Post.ts
            import { Entity, PrimaryKey, Property } from "@mikro-orm/core";
            import { Field, Int, ObjectType } from "type-graphql";

            @ObjectType()
            @Entity()
            export class Post {
                @Field(() => Int)
                @PrimaryKey()
                id!: number;

                @Field(() => String)
                @Property({ type: "date" })
                createdAt = new Date();

                @Field(() => String)
                @Property({ type: "date", onUpdate: () => new Date() })
                updatedAt = new Date();

                @Field()
                @Property({ type: "text" })
                title!: string;
            }


            ii. Change src/index.ts to include context into apolloServer.
            import "reflect-metadata";
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";
            import { ApolloServer } from "apollo-server-express";
            import { buildSchema } from "type-graphql";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            import { HelloResolver } from "./resolvers/hello";
            import { PostResolver } from "./resolvers/post";

            const main = async () => {
                //Connect to MikroORM
                const orm = await MikroORM.init(microConfig);
                //Run migrations
                await orm.getMigrator().up();

                const PORT = 4000;
                const app = express();

                const apolloServer = new ApolloServer({
                    schema: await buildSchema({
                    resolvers: [HelloResolver, PostResolver],
                    validate: false,
                    }),
                    context: () => ({ em: orm.em }),
                });

                apolloServer.applyMiddleware({ app });

                app.listen(PORT, () => {
                    console.log(`Server listening on port ${PORT}`);
                });
            };

            main().catch((e) => {
                console.log(e);
            });

            iii. Define MyContext type in types.ts.
            Note: find the type of em by hovering over orm.em, in /src/index.ts, and copy-pasting the type.
            //types.ts
            import { EntityManager, IDatabaseDriver, Connection } from "@mikro-orm/core";

            export type MyContext {
                em: EntityManager<any> & EntityManager<IDatabaseDriver<Connection>>
            }

            iv. Define PostResolver class, using context, with default `hello world` resolver.
            import { Post } from "src/entities/Post";
            import { Query, Resolver } from "type-graphql";

            @Resolver()
            export class PostResolver {
                @Query(() => [Post])
                hello() {
                    return "Hello world!";
                }
            }

            v. Define post resolvers
            import { Post } from "../entities/Post";
            import { MyContext } from "src/types";
            import { Arg, Ctx, Int, Mutation, Query, Resolver } from "type-graphql";

            @Resolver()
            export class PostResolver {
            @Query(() => [Post])
            posts(@Ctx() { em }: MyContext): Promise<Post[]> {
                return em.find(Post, {});
            }

            @Query(() => Post, { nullable: true })
            post(
                @Ctx() { em }: MyContext,
                @Arg("id", () => Int) id: number
            ): Promise<Post | null> {
                const post = em.findOne(Post, { id });
                return post;
            }

            @Mutation(() => Post)
            async createPost(
                @Ctx() { em }: MyContext,
                @Arg("title", () => String) title: string
            ): Promise<Post> {
                const post = em.create(Post, { title });
                await em.persistAndFlush(post);
                return post;
            }

            @Mutation(() => Post, { nullable: true })
            async updatePost(
                @Ctx() { em }: MyContext,
                @Arg("id", () => Number) id: number,
                @Arg("title", () => String, { nullable: true }) title: string
            ): Promise<Post | null> {
                const post = await em.findOne(Post, { id });
                if (!post) {
                    return null;
                }
                if (typeof title !== undefined) {
                    post.title = title;
                    await em.persistAndFlush(post);
                }
                return post;
            }

            @Mutation(() => Boolean)
            async deletePost(
                @Ctx() { em }: MyContext,
                @Arg("id", () => Number) id: number
            ): Promise<boolean> {
                try {
                await em.nativeDelete(Post, { id });
                return true;
                } catch (e) {
                console.log("Error", e);
                }
                return false;
            }
            }

    8. Authentication
        i. create:migration script to make life easier
            "create:migration": "mikro-orm migration:create"
        ii. Create User entity
            import { Entity, PrimaryKey, Property } from "@mikro-orm/core";
            import { Field, Int, ObjectType } from "type-graphql";

            @ObjectType()
            @Entity()
            export class User {
                @Field(() => Int)
                @PrimaryKey()
                id!: number;

                @Field(() => String)
                @Property({ type: "date" })
                createdAt = new Date();

                @Field(() => String)
                @Property({ type: "date", onUpdate: () => new Date() })
                updatedAt = new Date();

                @Property({ type: "text", unique: true })
                username!: string;

                @Property({ type: "text" })
                password!: string;
            }
        iii. Add User entity to micro-orm.config.ts
        import { MikroORM } from "@mikro-orm/core";
        import path from "path";
        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";
        import { User } from "./entities/User";

        export default {
            migrations: {
                path: path.join(__dirname, "./migrations"), // path to the folder with migrations
                pattern: /^[\w-]+\d+\.[tj]s$/, // regex pattern for the migration files (.js or .ts)
            },
            dbName: "lireddit",
            entities: [Post, User],
            type: "postgresql",
            debug: !__prod__,
        } as Parameters<typeof MikroORM.init>[0];

        iii. Create new migration via yarn create:migration`

        iv. Install to dependencies `argon2` (for password hashing)

        v. User resolvers
            - Create UserResolver in ./resolvers/user.ts
            - Add UserResolver to ApolloServer schema `resolvers`, in ./src/index.

            //resolvers/user.ts
            import { MyContext } from "src/types";
            import argon2 from "argon2";
            import {
            Arg,
            Ctx,
            Field,
            InputType,
            Mutation,
            ObjectType,
            Resolver,
            } from "type-graphql";
            import { User } from "../entities/User";

            @InputType()
            class UsernamePasswordInput {
                @Field()
                username: string;
                @Field(() => String)
                password: string;
            }

            @ObjectType()
            class FieldError {
                @Field(() => String)
                field: string;
                @Field(() => String)
                message: string;
            }

            @ObjectType()
            class UserResponse {
                @Field(() => [FieldError], { nullable: true })
                errors?: FieldError[];
                @Field(() => User, { nullable: true })
                user?: User;
            }

            @Resolver()
            export class UserResolver {
                @Mutation(() => UserResponse)
                async register(
                    @Ctx() { em }: MyContext,
                    @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
                ): Promise<UserResponse> {
                    if (input.username.length <= 2) {
                    return {
                        errors: [
                        {
                            field: "username",
                            message: "Length of provided username must be greater than 2.",
                        },
                        ],
                    };
                    }
                    if (input.password.length <= 3) {
                    return {
                        errors: [
                        {
                            field: "password",
                            message: "Length of provided password must be greater than 3.",
                        },
                        ],
                    };
                    }
                    const hashedPassword = await argon2.hash(input.password);
                    const user = em.create(User, {
                    username: input.username,
                    password: hashedPassword,
                    });
                    try {
                    await em.persistAndFlush(user);
                    } catch (err) {
                    console.log("message", err.message);
                    if (err.code === "23505" || err.detail.includes("already exists")) {
                        em.clear();
                        //duplicate username error
                        return {
                        errors: [
                            {
                            message: "This username already exists",
                            field: "username",
                            },
                        ],
                        };
                    }
                    return {
                        errors: [
                        {
                            message: "Something went wrong",
                            field: "Unknown",
                        },
                        ],
                    };
                    }
                    return { user };
                }

                @Mutation(() => UserResponse)
                async login(
                    @Ctx() { em }: MyContext,
                    @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
                ): Promise<UserResponse> {
                    const user = await em.findOne(User, { username: input.username });
                    if (!user) {
                    return {
                        errors: [
                        {
                            field: "username",
                            message: "That username doesn't exist",
                        },
                        ],
                    };
                    }
                    const hashedPassword = user.password;
                    const isGoodPassword = await argon2.verify(hashedPassword, input.password);
                    if (!isGoodPassword) {
                    return {
                        errors: [
                        {
                            field: "password",
                            message: "That password is incorrect",
                        },
                        ],
                    };
                    }
                    return { user };
                }
            }

        
    8. User session 
        i. Install redis - https://formulae.brew.sh/formula/redis
        ii. Create new redis scripts
            "start-redis": "brew services start redis",
            "stop-redis": "brew services stop redis",
        iii. Install to dependencies:
            "connect-redis": "^5.0.0",
            "express-session": "^1.17.1",
            "redis": "^3.0.2",
        iv. Install to devDependencies:
            "@types/connect-redis": "^0.0.14",
            "@types/express-session": "^1.17.0",
            "@types/redis": "^2.8.27",
        v. Add request and response to custom context definition, in ./src/types.ts
        import { EntityManager, IDatabaseDriver, Connection } from "@mikro-orm/core";
        import { Request, Response } from "express";

        export type MyContext = {
            em: EntityManager<any> & EntityManager<IDatabaseDriver<Connection>>;
            req: Request & { session: Express.Session };
            res: Response;
        };

        v. Add redis to app in ./src/index.ts; redis config, and add to context
        //src/index.ts
        import "reflect-metadata";
        import { MikroORM } from "@mikro-orm/core";
        import express from "express";
        import { ApolloServer } from "apollo-server-express";
        import { buildSchema } from "type-graphql";

        import { __prod__ } from "./constants";
        import microConfig from "./mikro-orm.config";

        import { HelloResolver } from "./resolvers/hello";
        import { PostResolver } from "./resolvers/post";
        import { UserResolver } from "./resolvers/user";

        import connectRedis from "connect-redis";
        import redis from "redis";
        import session from "express-session";

        const main = async () => {
            //Connect to MikroORM
            const orm = await MikroORM.init(microConfig);
            //Run migrations
            await orm.getMigrator().up();

            const PORT = 4000;
            const app = express();

            const RedisStore = connectRedis(session);
            const redisClient = redis.createClient();

            app.use(
                session({
                name: "qid",
                store: new RedisStore({ client: redisClient, disableTouch: true }),
                cookie: {
                    //No access to cookie from frontend
                    httpOnly: true,
                    //Set cookie lifespan to 10 years
                    maxAge: 1000 * 60 * 60 * 24 * 365 * 10,
                    //Only work for https
                    secure: __prod__,
                    sameSite: 'lax',//csrf

                },
                saveUninitialized: false,
                secret: "hbfwelmxlzwjdcdllw",
                resave: false,
                })
            );

            const apolloServer = new ApolloServer({
                schema: await buildSchema({
                    resolvers: [HelloResolver, PostResolver, UserResolver],
                    validate: false,
                }),
                context: ({req, res}) => ({ em: orm.em, req, res }),
            });


            apolloServer.applyMiddleware({ app });

            app.listen(PORT, () => {
                console.log(`Server listening on port ${PORT}`);
            });
        };

        main().catch((e) => {
            console.log(e);
        });
        
        vi. Add user id to request session on login
        //src/resolvers/user
        ...
        @Mutation(() => UserResponse)
        async login(
            @Ctx() { em, req }: MyContext,
            @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
        ): Promise<UserResponse> {
            const user = await em.findOne(User, { username: input.username });
            if (!user) {
            return {
                errors: [
                {
                    field: "username",
                    message: "That username doesn't exist",
                },
                ],
            };
            }
            const hashedPassword = user.password;
            const isGoodPassword = await argon2.verify(hashedPassword, input.password);
            if (!isGoodPassword) {
            return {
                errors: [
                {
                    field: "password",
                    message: "That password is incorrect",
                },
                ],
            };
            }

            req.session.userId = user.id; //<-- set to session here
            return { user };
        }
        ...

        vii. Test everything on local playground
            NOTE: For this to work, you must go into the local playground settings and set 
                "request.credentials":"include"
        Delete cookies via DevTools > Application > Cookies
        Hit login, with proper credentials, and observe the results; you should see a cookie qid.

        viii. Implement user log in on register, implement me query
        import { MyContext } from "src/types";
        import argon2 from "argon2";
        import {
        Arg,
        Ctx,
        Field,
        InputType,
        Mutation,
        Query,
        ObjectType,
        Resolver,
        } from "type-graphql";
        import { User } from "../entities/User";

        @InputType()
        class UsernamePasswordInput {
        @Field()
        username: string;
        @Field(() => String)
        password: string;
        }

        @ObjectType()
        class FieldError {
        @Field(() => String)
        field: string;
        @Field(() => String)
        message: string;
        }

        @ObjectType()
        class UserResponse {
        @Field(() => [FieldError], { nullable: true })
        errors?: FieldError[];
        @Field(() => User, { nullable: true })
        user?: User;
        }

        @Resolver()
        export class UserResolver {
        @Query(() => User, { nullable: true })
        async me(@Ctx() { req, em }: MyContext) {
            if (!req.session.userId) {
            return null;
            }
            const user = await em.findOne(User, { id: req.session.userId });
            return user;
        }

        @Mutation(() => UserResponse)
        async register(
            @Ctx() { em, req }: MyContext,
            @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
        ): Promise<UserResponse> {
            if (input.username.length <= 2) {
            return {
                errors: [
                {
                    field: "username",
                    message: "Length of provided username must be greater than 2.",
                },
                ],
            };
            }
            if (input.password.length <= 3) {
            return {
                errors: [
                {
                    field: "password",
                    message: "Length of provided password must be greater than 3.",
                },
                ],
            };
            }
            const hashedPassword = await argon2.hash(input.password);
            const user = em.create(User, {
            username: input.username,
            password: hashedPassword,
            });
            try {
            await em.persistAndFlush(user);
            } catch (err) {
            console.log("message", err.message);
            if (err.code === "23505" || err.detail.includes("already exists")) {
                em.clear();
                //duplicate username error
                return {
                errors: [
                    {
                    message: "This username already exists",
                    field: "username",
                    },
                ],
                };
            }
            return {
                errors: [
                {
                    message: "Something went wrong",
                    field: "Unknown",
                },
                ],
            };
            }

            //Store user ID on session
            //This will add a cookie on the session
            //Keep the user logged in
            req.session.userId = user.id;

            return { user };
        }

        @Mutation(() => UserResponse)
        async login(
            @Ctx() { em, req }: MyContext,
            @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
        ): Promise<UserResponse> {
            const user = await em.findOne(User, { username: input.username });
            if (!user) {
            return {
                errors: [
                {
                    field: "username",
                    message: "That username doesn't exist",
                },
                ],
            };
            }
            const hashedPassword = user.password;
            const isGoodPassword = await argon2.verify(hashedPassword, input.password);
            if (!isGoodPassword) {
            return {
                errors: [
                {
                    field: "password",
                    message: "That password is incorrect",
                },
                ],
            };
            }

            req.session.userId = user.id;
            return { user };
        }
        }
        

Frontend:
1. Use nextJS with ChakraUI: https://github.com/vercel/next.js/tree/canary/examples/with-chakra-ui
See https://chakra-ui.com/getting-started for more info on their services, we're going to be using their FormControl components
2. Remove all components, replace index.js with default Hello world div, replace extensions of index, _app, and theme to tsx.
3. Add to devDependencies:
    "@types/node": "^14.11.8",
    "typescript": "^4.0.3"
4. Add to dependencies:
    "formik": "^2.2.0",
5. Create generic InputField component
    import {
    FormControl,
    FormLabel,
    Input,
    FormErrorMessage,
    } from "@chakra-ui/core";
    import { useField } from "formik";
    import React, { InputHTMLAttributes } from "react";

    type InputFieldProps = InputHTMLAttributes<HTMLInputElement> & {
    label: string;
    name: string;
    };

    export const InputField: React.FC<InputFieldProps> = ({
    label,
    size: _,
    ...props
    }) => {
    const [field, { error }] = useField(props);

    return (
        <FormControl isInvalid={!!error}>
        <FormLabel htmlFor={field.name}>{label}</FormLabel>
        <Input {...field} {...props} id={field.name} />
        {error ? <FormErrorMessage>{error}</FormErrorMessage> : null}
        </FormControl>
    );
    };

5. Create register page   
    import React from "react";
    import { Formik, Form } from "formik";
    import {
    Box,
    Button,
    FormControl,
    FormErrorMessage,
    FormLabel,
    Input,
    } from "@chakra-ui/core";
    import { Wrapper } from "../components/Wrapper";
    import { InputField } from "../components/InputField";
    import { useMutation } from "urql";

    const REGISTER_MUTATION = `
    mutation Register($username: String!, $password:String!){
        register(input: {username: $username, password: $password}){
        errors{
            field
            message
        }
        user{
            id
            username
        }
        }
    }
    `;

    interface registerProps {}

    const Register: React.FC<registerProps> = ({}) => {
    const [{ data, error }, register] = useMutation(REGISTER_MUTATION);

    return (
        <Wrapper variant="small">
        <Formik
            initialValues={{ username: "", password: "" }}
            onSubmit={(values) => {
            console.log(values);
            //return promise to end spinner on resolve
            return register(values);
            }}
        >
            {({ isSubmitting }) => (
            <Form>
                <InputField
                label="Username"
                placeholder="username"
                name="username"
                />
                <Box mt={4}>
                <InputField
                    label="Password"
                    placeholder="password"
                    name="password"
                    type="password"
                />
                </Box>
                <Button
                mt={4}
                isLoading={isSubmitting}
                type="submit"
                variantColor="teal"
                >
                Submit
                </Button>
            </Form>
            )}
        </Formik>
        </Wrapper>
    );
    };

    export default Register;


6. Set up GraphQL URQL client
https://formidable.com/open-source/urql/docs/
    a. add to frontend dependencies
        "graphql": "^15.3.0",
        "urql": "^1.10.1"
    b. Create urql client in _app.tsx
        import { ThemeProvider, CSSReset, ColorModeProvider } from "@chakra-ui/core";

        import theme from "../theme";

        import { createClient, Provider } from "urql";
        const client = createClient({
        url: "http://localhost:4000/graphql",
            fetchOptions: {
                credentials: "include",
            },
        });

        function MyApp({ Component, pageProps }) {
        return (
            <Provider value={client}>
                <ThemeProvider theme={theme}>
                    <ColorModeProvider>
                    <CSSReset />
                    <Component {...pageProps} />
                    </ColorModeProvider>
                </ThemeProvider>
            </Provider>
        );
        }

        export default MyApp;
    
    c. Add to backend dependencies
        "cors": "^2.8.5",
    d. Add to backend devDependencies
        "@types/cors": "^2.8.8",  
    e. Add cors to backend app on src/index.ts
    import "reflect-metadata";
    import { MikroORM } from "@mikro-orm/core";
    import express from "express";
    import { ApolloServer } from "apollo-server-express";
    import { buildSchema } from "type-graphql";

    import { __prod__ } from "./constants";
    import microConfig from "./mikro-orm.config";

    import { HelloResolver } from "./resolvers/hello";
    import { PostResolver } from "./resolvers/post";
    import { UserResolver } from "./resolvers/user";

    import connectRedis from "connect-redis";
    import redis from "redis";
    import session from "express-session";

    import cors from "cors";

    const main = async () => {
        //Connect to MikroORM
        const orm = await MikroORM.init(microConfig);
        //Run migrations
        await orm.getMigrator().up();

        const PORT = 4000;
        const app = express();

        const RedisStore = connectRedis(session);
        const redisClient = redis.createClient();

        app.use(
            cors({
                origin: "http://localhost:3000",
                credentials: true,
            })
        );

        app.use(
            session({
                name: "qid",
                store: new RedisStore({ client: redisClient, disableTouch: true }),
                cookie: {
                    //No access to cookie from frontend
                    httpOnly: true,
                    //Set cookie lifespan to 10 years
                    maxAge: 1000 * 60 * 60 * 24 * 365 * 10,
                    //Only work for https
                    secure: __prod__,
                    sameSite: "lax", //csrf
                },
                saveUninitialized: false,
                secret: "hbfwelmxlzwjdcdllw",
                resave: false,
            })
        );

        const apolloServer = new ApolloServer({
            schema: await buildSchema({
                resolvers: [HelloResolver, PostResolver, UserResolver],
                validate: false,
            }),
            context: ({ req, res }) => ({ em: orm.em, req, res }),
        });

        apolloServer.applyMiddleware({
            app,
            cors: false,
        });

        app.listen(PORT, () => {
            console.log(`Server listening on port ${PORT}`);
        });
    };

    main().catch((e) => {
        console.log(e);
    });
      
7. Ensure types returned from our mutators are of desired Typescript types
    a. Install GraphQL code generator
    https://graphql-code-generator.com/docs/getting-started/installation
    Note: We already have graphql, so we're just going to want to add to frontend devDependencies:
        "@graphql-codegen/cli": "^1.17.10",
    We're then going to proceed with the initialization wizard: https://graphql-code-generator.com/docs/getting-started/installation#initialization-wizard

    jq@Jacques-Philippes-MacBook-Air frontend % yarn graphql-codegen init
    yarn run v1.22.5
    $ /Users/jq/Desktop/Learning/Fullstack_React_GraphQL_Typescript_Tutorial/Application/frontend/node_modules/.bin/graphql-codegen init

    Welcome to GraphQL Code Generator!
    Answer few questions and we will setup everything for you.
  
    ? What type of application are you building? Application built with React
    ? Where is your schema?: (path or url) http://localhost:4000/graphql
    ? Where are your operations and fragments?: src/graphql/**/*.graphql
    ? Pick plugins: TypeScript (required by other typescript plugins), TypeScript Operations (operations and fragments)
    ? Where to write the output: src/generated/graphql.tsx
    ? Do you want to generate an introspection file? No
    ? How to name the config file? codegen.yml
    ? What script in package.json should run the codegen? gen

    Notice after this that we have a new 'gen' script in package.json.

    b. Edit codegen.yml to:
        overwrite: true
        schema: "http://localhost:4000/graphql"
        documents: "src/graphql/**/*.graphql"
        generates:
        src/generated/graphql.tsx:
            plugins:
            - "typescript"
            - "typescript-operations"
            - "typescript-urql"

    c. (https://graphql-code-generator.com/docs/generated-config/typescript-urql/) Add to frontend devDependencies:
        "@graphql-codegen/typescript-urql": "^2.0.2",

    d. Create `./frontend/src/graphql/mutations/register.graphql`:
    mutation Register($username: String!, $password: String!) {
        register(input: { username: $username, password: $password }) {
            errors {
                field
                message
            }
            user {
                id
                username
            }
        }
    }

    e. Run new 'gen' script, this will create ./frontend/src/generated/graphql.tsx
        $ yarn gen

    f. The generated file above will contain our mutation and query hooks, which we can use via import, now. Our new pages/register.tsx is as follows:
    import React from "react";
    import { Formik, Form } from "formik";
    import {
    Box,
    Button,
    FormControl,
    FormErrorMessage,
    FormLabel,
    Input,
    } from "@chakra-ui/core";
    import { Wrapper } from "../components/Wrapper";
    import { InputField } from "../components/InputField";
    import { useRegisterMutation } from "../generated/graphql";

    interface registerProps {}

    const Register: React.FC<registerProps> = ({}) => {
    const [{ data, error }, register] = useRegisterMutation();

    return (
        <Wrapper variant="small">
        <Formik
            initialValues={{ username: "", password: "" }}
            onSubmit={async (values) => {
            console.log(values);
            //return promise to end spinner on resolve
            const response = await register(values);
            }}
        >
            {({ isSubmitting }) => (
            <Form>
                <InputField
                label="Username"
                placeholder="username"
                name="username"
                />
                <Box mt={4}>
                <InputField
                    label="Password"
                    placeholder="password"
                    name="password"
                    type="password"
                />
                </Box>
                <Button
                mt={4}
                isLoading={isSubmitting}
                type="submit"
                variantColor="teal"
                >
                Submit
                </Button>
            </Form>
            )}
        </Formik>
        </Wrapper>
    );
    };

    export default Register;

    Notice now the type of our register mutation is now RegisterMutation, instead of something more general, which is what we want.






A note on using typescript to access deeply-nested data which may or may not be undefined:
If we make a fetch returning to us 
    if (response.data.register.errors){
        //do something
    }
for example, it would be possible for us to getg an error in the case where data returned as undefined. In the past we would have to handle this either by chaining ORs, or what-have-you. We can do this more neatly in typescript, with the following:    
    if (response.data?.register.errors){
            //do something
    }
This allows us to more succintly handle the case wherein data is undefined.    



Typescript-react code snippets:
https://gist.github.com/benawad/1e9dd01994f78489306fbfd6f7b01cd3#file-snippets-typescriptreact-json
Add the above to your typescriptreact.json file to have some sick new custom code snippets  


A note on what's happening with session.
When we do req.session.userId = user.id, we're storing the user's id on the session. Behind the scenes, any data that we store on our req is going to be stored on redis, and redis is a key-value store. After the data is stored on redis, a signed version of the key it's saved under is sent to the browser, and whenever the user makes a request, a copy of that key is sent to the server to test for authorization to access the requisite data. After the cookie is 

In which order does my express middleware run? In the same order as you add it onto our app.

How do I know which types I may need to install after installing new packages?
If the import is highlighted in red, hovering over it should tell us which types are missing.

We're using Connect-Redis for our redis. 
https://github.com/tj/connect-redis

If you find the GraphQL server becoming unresponsive following a failed entry because of a violated unique constraint, consider using em.clear().
https://github.com/mikro-orm/mikro-orm/issues/696
Here is my use case:
    @Resolver()
    export class UserResolver {
    @Mutation(() => UserResponse)
    async register(
        @Ctx() { em }: MyContext,
        @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
    ): Promise<UserResponse> {
        const hashedPassword = await argon2.hash(input.password);
        const user = em.create(User, {
            username: input.username,
            password: hashedPassword,
        });
        try {
        await em.persistAndFlush(user);
        } catch (err) {
        console.log("message", err.message);
        if (err.code === "23505" || err.detail.includes("already exists")) {
            // *** Over here ***
            em.clear();
            
            //duplicate username error
            return {
            errors: [
                {
                message: "This username already exists",
                field: "username",
                },
            ],
            };
        }
        return {
            errors: [
            {
                message: "Something went wrong",
                field: "Unknown",
            },
            ],
        };
        }
        return { user };
    }

A note on creating ObjectType or InputType variables with a ?
@ObjectType()
class UserResponse {
  @Field()
  errors?: Error[];
  @Field(() => String)
  user?: User;
}
In the above, we initialize errors and user as undefined.

A note on why ObjectType vs InputType as class declarations.
ObjectTypes we return from our resolvers, whereas InputTypes we receive as arguments.    

What does it do for us to implement our HelloResolver in our src/index.ts schema definition? What this does for us is it defines a graphQL endpoint for our queries.


Before losing your mind on debugging:
Make sure your dist looks the way it should. It's possible that over the course of programming, it gets filled up with a lot of trash (or duplicates from slightly different files). The solution? Erase dist and re-run our `start` and `watch` script, to remake a fresh one.

A note on module not found from the resolvers:
Not sure why, but over in the resolver definitions, we need to need to specify the entity type via the '../entities/post' format, as opposed to the more general 'src/entities/post'. Not sure why.

A note on error TS2307: Cannot find module 'class-validator' or its corresponding type declarations.
For this you need to add 'class-validator' to dev dependencies.
Awad also shows us another way to solve this, by adding `"skipLibCheck": true` in tsconfig.json

A note on the purpose of our mikro-orm.config.ts:
We make this src/mikro-orm.config.ts in order to be able to access our custom data types from our MikroORM CLI.

A note on why not to use 'ts-node': 
- it's slow
- when we get to production, we don't use ts-node; we compile to JS and execute that. We elect not to use ts-node to be closer to the production environment, in dev
Our solution to ts-node?
- A 'watch' script executing typescript with the watch flag, to monitor file changes to src/index.ts; spits out a dist build (JS) on file change.
- A 'dev' script to execute 'nodemon' on our produced dist directory, coming from the watch script. To the difference of 'node', 'nodemon' will listen for changes made to our compiled dist file, resulting from our watch script.
Note that the two points above must be two scripts running in tandem. We can do this either in two separate terminal instances, or at once via 'concurrently' package.

A note on the difference between orm.em.create, orm.em.persistAndFlush and orm.em.nativeInsert:

A note on node `path` and `__dirname`
These variables come installed in node, and basically they help us ensure that we're running things from the right place, and we have access to the imports we need. __dirname is a pre-defined global variable whose value corresponds to the absolute path leading to the file it's called in (at run time, which is pertinent for us, because we're transpiling before running).

A note on migrations in MikroORM.
After running the $ npx mikro-orm migration:create, from https://mikro-orm.io/docs/migrations/#using-via-cli, we'll have a new migrations directory with the literal SQL generated by our data definitions in our entities. In the migrations, we can see the data types of all of our properties.



Tutorial reference: https://www.youtube.com/watch?v=I6ypD7qv3Z8&ab_channel=BenAwad

A note on text editors:
I don't give a fuck who you think you are, use VS Code.

A note on extensions:
To see extensions which are currently installed, you can enter into the searchbar command @installed.

VS Code extensions:
- Bracket Pair Colorizer 2 (0.2.0)
- Docker (1.6.0)
- GraphQL for VSCode (1.15.3)
- Prettier - Code formatter (5.7.1)
- Vim (1.17.1) - Disabled for now

How to enable auto-formatting on save for VS Code. 
You can achieve the same result by messing with your settings, which is fine, you can find the relevant config over on the Prettier - Code formatter docs, but you can also do the following, simply via the editor settings:
Code > Preferences > Settings > User. Search for "format", and check "format on save"

Backend init steps:
1. New package.json to backend root
2. Install packages 
    a. devDependencies:
        "@types/node": "^14.11.5",
        "concurrently": "^5.3.0",
        "nodemon": "^2.0.4",
        "ts-node": "^9.0.0",
        "typescript": "^4.0.3"
    b. dependencies:
        "@mikro-orm/cli": "^4.0.7",
        "@mikro-orm/core": "^4.0.7",
        "@mikro-orm/migrations": "^4.0.7",
        "@mikro-orm/postgresql": "^4.0.7",
        "pg": "^8.4.0"    

3. tsconfig.json to backend root
    $ npx tsconfig.json

4. Create the following src/index.ts to test the functionality of the scripts which follow:
//src/index.ts:
console.log('Hello world!');

5. New scripts to package.json (remove comments after copy-paste)
"scripts":[
    //Transpile ts to js, retranspile on file change
    "watch" : "tsc -w",
    //Compile generated js
    "start": "nodemon dist/index.js"
]    

6. Initialize db
    a. if needed, install postgresql 
        $ brew install postgresql
    b. Ensure successful install via 
        $ postgres -V
    c. Ensure existence of postgres default account with the following:
        1. $ psql postgres
        2. postgres=# \du
        3. (Optional) If now you DON'T see postgres account listed, exit and run the following:
            a. $ createuser -s postgres
                  
    d. (Optional) add db scripts to package.json, for instance:
        "pg-start": "brew services start postgresql",
        "pg-stop" : "brew services stop postgresql"

    e. (After starting postgresql instance via 'pg-start' script defined above) create new db.
        $ createdb [DB_NAME]

    d. Create a new entity, in accordance with mikro-orm docs: https://mikro-orm.io/docs/defining-entities/
    //entities/Post.ts:
    import { Entity, PrimaryKey, Property } from "@mikro-orm/core";

    @Entity()
    export class Post {
        @PrimaryKey()
        id!: number;

        @Property({ type: "date" })
        createdAt = new Date();

        @Property({ type: "date", onUpdate: () => new Date() })
        updatedAt = new Date();

        @Property({ type: "text" })
        title!: string;
    }


    e. Set up MikroORM CLI to allow for ops to db.
        i. Add to package.json (Source: https://mikro-orm.io/docs/installation#setting-up-the-commandline-tool):
        {
            "name": "your-app",
            "dependencies": { ... },
            "mikro-orm": {
                "useTsNode": true,
                "configPaths": [
                "./src/mikro-orm.config.ts",
                "./dist/mikro-orm.config.js"
                ]
            }
        }
        
        ii. Create 'src/mikro-orm.config.ts' with the following:
        //Source: https://mikro-orm.io/docs/migrations/#configuration
        import { MikroORM } from "@mikro-orm/core";
        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";

        import path from "path";

        export default {
            migrations: {
                path: path.join(__dirname, "./migrations"), // path to the folder with migrations
                pattern: /^[\w-]+\d+\.[tj]s$/, // regex pattern for the migration files (.js or .ts)
            },
            dbName: "lireddit",
            entities: [Post],
            type: "postgresql",
            debug: !__prod__,
        } as Parameters<typeof MikroORM.init>[0];

        iii. Have the following as src/index.ts
        //src/index.ts
        import { MikroORM } from "@mikro-orm/core";
        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";

        import microConfig from "./mikro-orm.config";

        const main = async () => {
            const orm = await MikroORM.init(microConfig);

            //Create a new Post (does not affect db)
            const post = orm.em.create(Post, { title: "My first post" });
            await orm.em.persistAndFlush(post);
            console.log("--------------SQL 2-------------------");
            await orm.em.persistAndFlush(post);
        };

        main().catch((e) => {
            console.log(e);
        });

        
        iv. Create MikroORM migration via CLI command 
        (Source: https://mikro-orm.io/docs/migrations/#using-via-cli)
            $ npx mikro-orm migration:create
        If running the above gives you the "role postgres doesn't exist" error (which means there's no defined postgres user), then see 5.c.3, '(Optional) If now you DON'T see postgres account listed, exit and run the following'.

        v. Delete `dist` folder, for now, to avoid problems later with duplicates.

        vi. Automate migration by including it in src/index.ts. Modify src/index.ts to the following. Test success with `start` and `watch` command chain.
        //src/index.ts
        import { MikroORM } from "@mikro-orm/core";

        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";
        import microConfig from "./mikro-orm.config";

        const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                //Create a new Post (does not affect db)
                const post = orm.em.create(Post, { title: "My first post" });
                await orm.em.persistAndFlush(post);
            };

            main().catch((e) => {
            console.log(e);
        });
    7. Initialize server
        a. Add to dependencies:
            "apollo-server-express": "^2.18.2",
            "express": "^4.17.1",
            "graphql": "^15.3.0",
            "type-graphql": "^1.0.0",
            "reflect-metadata": "^0.1.13"
        b. Add to devDependencies
            "@types/express": "^4.17.8",
        c. Test express works properly with the following:
            1. ensure src/index.ts matches:
            import "reflect-metadata";
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                const app = express();
                const PORT = 4000;

                app.get("/", (req, res) => {
                    res.send("Hello world from Express!");
                });

                app.listen(PORT, () => {
                    console.log(`Server listening on port ${PORT}`);
                });
            };

            main().catch((e) => {
                console.log(e);
            });

            2. Navigate to http://localhost:4000, you should receive "Hello world from Express!"
        d. Set up apollo-server-express
            i. Create HelloResolver class
            //src/resolvers/hello.ts  
            import { Query, Resolver } from "type-graphql";

            @Resolver()
            export class HelloResolver {
                @Query(() => String)
                hello() {
                    return "Hello world!";
                }
            }
            ii. Implement hello resolver in apollo-server graphql schema
            //src/index.ts
            import "reflect-metadata";
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";
            import { ApolloServer } from "apollo-server-express";
            import { buildSchema } from "type-graphql";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            import { HelloResolver } from "./resolvers/hello";

            const main = async () => {
                const orm = await MikroORM.init(microConfig);
                await orm.getMigrator().up();

                const PORT = 4000;
                const app = express();

                const apolloServer = new ApolloServer({
                    schema: await buildSchema({
                    resolvers: [HelloResolver],
                    validate: false,
                    }),
                });

                apolloServer.applyMiddleware({ app });

                app.listen(PORT, () => {
                    console.log(`Server listening on port ${PORT}`);
                });
            };

            main().catch((e) => {
                console.log(e);
            });
            iii. Verify successful graphQL endpoint by navigating to http://localhost:4000 and trying out the `hello` query. You should see as output 'Hello world'
        e. Combine apollo-server-express with MikroORM for some CRUD ops
            i. Modify Post entity to be a GraphQL type via @ObjectType declaration, specifying the return types of each field.
            //src/entities/Post.ts
            import { Entity, PrimaryKey, Property } from "@mikro-orm/core";
            import { Field, Int, ObjectType } from "type-graphql";

            @ObjectType()
            @Entity()
            export class Post {
                @Field(() => Int)
                @PrimaryKey()
                id!: number;

                @Field(() => String)
                @Property({ type: "date" })
                createdAt = new Date();

                @Field(() => String)
                @Property({ type: "date", onUpdate: () => new Date() })
                updatedAt = new Date();

                @Field()
                @Property({ type: "text" })
                title!: string;
            }


            ii. Change src/index.ts to include context into apolloServer.
            import "reflect-metadata";
            import { MikroORM } from "@mikro-orm/core";
            import express from "express";
            import { ApolloServer } from "apollo-server-express";
            import { buildSchema } from "type-graphql";

            import { __prod__ } from "./constants";
            import microConfig from "./mikro-orm.config";

            import { HelloResolver } from "./resolvers/hello";
            import { PostResolver } from "./resolvers/post";

            const main = async () => {
                //Connect to MikroORM
                const orm = await MikroORM.init(microConfig);
                //Run migrations
                await orm.getMigrator().up();

                const PORT = 4000;
                const app = express();

                const apolloServer = new ApolloServer({
                    schema: await buildSchema({
                    resolvers: [HelloResolver, PostResolver],
                    validate: false,
                    }),
                    context: () => ({ em: orm.em }),
                });

                apolloServer.applyMiddleware({ app });

                app.listen(PORT, () => {
                    console.log(`Server listening on port ${PORT}`);
                });
            };

            main().catch((e) => {
                console.log(e);
            });

            iii. Define MyContext type in types.ts.
            Note: find the type of em by hovering over orm.em, in /src/index.ts, and copy-pasting the type.
            //types.ts
            import { EntityManager, IDatabaseDriver, Connection } from "@mikro-orm/core";

            export type MyContext {
                em: EntityManager<any> & EntityManager<IDatabaseDriver<Connection>>
            }

            iv. Define PostResolver class, using context, with default `hello world` resolver.
            import { Post } from "src/entities/Post";
            import { Query, Resolver } from "type-graphql";

            @Resolver()
            export class PostResolver {
                @Query(() => [Post])
                hello() {
                    return "Hello world!";
                }
            }

            v. Define post resolvers
            import { Post } from "../entities/Post";
            import { MyContext } from "src/types";
            import { Arg, Ctx, Int, Mutation, Query, Resolver } from "type-graphql";

            @Resolver()
            export class PostResolver {
            @Query(() => [Post])
            posts(@Ctx() { em }: MyContext): Promise<Post[]> {
                return em.find(Post, {});
            }

            @Query(() => Post, { nullable: true })
            post(
                @Ctx() { em }: MyContext,
                @Arg("id", () => Int) id: number
            ): Promise<Post | null> {
                const post = em.findOne(Post, { id });
                return post;
            }

            @Mutation(() => Post)
            async createPost(
                @Ctx() { em }: MyContext,
                @Arg("title", () => String) title: string
            ): Promise<Post> {
                const post = em.create(Post, { title });
                await em.persistAndFlush(post);
                return post;
            }

            @Mutation(() => Post, { nullable: true })
            async updatePost(
                @Ctx() { em }: MyContext,
                @Arg("id", () => Number) id: number,
                @Arg("title", () => String, { nullable: true }) title: string
            ): Promise<Post | null> {
                const post = await em.findOne(Post, { id });
                if (!post) {
                    return null;
                }
                if (typeof title !== undefined) {
                    post.title = title;
                    await em.persistAndFlush(post);
                }
                return post;
            }

            @Mutation(() => Boolean)
            async deletePost(
                @Ctx() { em }: MyContext,
                @Arg("id", () => Number) id: number
            ): Promise<boolean> {
                try {
                await em.nativeDelete(Post, { id });
                return true;
                } catch (e) {
                console.log("Error", e);
                }
                return false;
            }
            }

    8. Authentication
        i. create:migration script to make life easier
            "create:migration": "mikro-orm migration:create"
        ii. Create User entity
            import { Entity, PrimaryKey, Property } from "@mikro-orm/core";
            import { Field, Int, ObjectType } from "type-graphql";

            @ObjectType()
            @Entity()
            export class User {
                @Field(() => Int)
                @PrimaryKey()
                id!: number;

                @Field(() => String)
                @Property({ type: "date" })
                createdAt = new Date();

                @Field(() => String)
                @Property({ type: "date", onUpdate: () => new Date() })
                updatedAt = new Date();

                @Property({ type: "text", unique: true })
                username!: string;

                @Property({ type: "text" })
                password!: string;
            }
        iii. Add User entity to micro-orm.config.ts
        import { MikroORM } from "@mikro-orm/core";
        import path from "path";
        import { __prod__ } from "./constants";
        import { Post } from "./entities/Post";
        import { User } from "./entities/User";

        export default {
            migrations: {
                path: path.join(__dirname, "./migrations"), // path to the folder with migrations
                pattern: /^[\w-]+\d+\.[tj]s$/, // regex pattern for the migration files (.js or .ts)
            },
            dbName: "lireddit",
            entities: [Post, User],
            type: "postgresql",
            debug: !__prod__,
        } as Parameters<typeof MikroORM.init>[0];

        iii. Create new migration via yarn create:migration`

        iv. Install to dependencies `argon2` (for password hashing)

        v. User resolvers
            - Create UserResolver in ./resolvers/user.ts
            - Add UserResolver to ApolloServer schema `resolvers`, in ./src/index.

            //resolvers/user.ts
            import { MyContext } from "src/types";
            import argon2 from "argon2";
            import {
            Arg,
            Ctx,
            Field,
            InputType,
            Mutation,
            ObjectType,
            Resolver,
            } from "type-graphql";
            import { User } from "../entities/User";

            @InputType()
            class UsernamePasswordInput {
                @Field()
                username: string;
                @Field(() => String)
                password: string;
            }

            @ObjectType()
            class FieldError {
                @Field(() => String)
                field: string;
                @Field(() => String)
                message: string;
            }

            @ObjectType()
            class UserResponse {
                @Field(() => [FieldError], { nullable: true })
                errors?: FieldError[];
                @Field(() => User, { nullable: true })
                user?: User;
            }

            @Resolver()
            export class UserResolver {
                @Mutation(() => UserResponse)
                async register(
                    @Ctx() { em }: MyContext,
                    @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
                ): Promise<UserResponse> {
                    if (input.username.length <= 2) {
                    return {
                        errors: [
                        {
                            field: "username",
                            message: "Length of provided username must be greater than 2.",
                        },
                        ],
                    };
                    }
                    if (input.password.length <= 3) {
                    return {
                        errors: [
                        {
                            field: "password",
                            message: "Length of provided password must be greater than 3.",
                        },
                        ],
                    };
                    }
                    const hashedPassword = await argon2.hash(input.password);
                    const user = em.create(User, {
                    username: input.username,
                    password: hashedPassword,
                    });
                    try {
                    await em.persistAndFlush(user);
                    } catch (err) {
                    console.log("message", err.message);
                    if (err.code === "23505" || err.detail.includes("already exists")) {
                        em.clear();
                        //duplicate username error
                        return {
                        errors: [
                            {
                            message: "This username already exists",
                            field: "username",
                            },
                        ],
                        };
                    }
                    return {
                        errors: [
                        {
                            message: "Something went wrong",
                            field: "Unknown",
                        },
                        ],
                    };
                    }
                    return { user };
                }

                @Mutation(() => UserResponse)
                async login(
                    @Ctx() { em }: MyContext,
                    @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
                ): Promise<UserResponse> {
                    const user = await em.findOne(User, { username: input.username });
                    if (!user) {
                    return {
                        errors: [
                        {
                            field: "username",
                            message: "That username doesn't exist",
                        },
                        ],
                    };
                    }
                    const hashedPassword = user.password;
                    const isGoodPassword = await argon2.verify(hashedPassword, input.password);
                    if (!isGoodPassword) {
                    return {
                        errors: [
                        {
                            field: "password",
                            message: "That password is incorrect",
                        },
                        ],
                    };
                    }
                    return { user };
                }
            }

        
    8. User session 
        i. Install redis - https://formulae.brew.sh/formula/redis
        ii. Create new redis scripts
            "start-redis": "brew services start redis",
            "stop-redis": "brew services stop redis",
        iii. Install to dependencies:
            "connect-redis": "^5.0.0",
            "express-session": "^1.17.1",
            "redis": "^3.0.2",



We're using Connect-Redis for our redis. 
https://github.com/tj/connect-redis

If you find the GraphQL server becoming unresponsive following a failed entry because of a violated unique constraint, consider using em.clear().
https://github.com/mikro-orm/mikro-orm/issues/696
Here is my use case:
    @Resolver()
    export class UserResolver {
    @Mutation(() => UserResponse)
    async register(
        @Ctx() { em }: MyContext,
        @Arg("input", () => UsernamePasswordInput) input: UsernamePasswordInput
    ): Promise<UserResponse> {
        const hashedPassword = await argon2.hash(input.password);
        const user = em.create(User, {
            username: input.username,
            password: hashedPassword,
        });
        try {
        await em.persistAndFlush(user);
        } catch (err) {
        console.log("message", err.message);
        if (err.code === "23505" || err.detail.includes("already exists")) {
            // *** Over here ***
            em.clear();
            
            //duplicate username error
            return {
            errors: [
                {
                message: "This username already exists",
                field: "username",
                },
            ],
            };
        }
        return {
            errors: [
            {
                message: "Something went wrong",
                field: "Unknown",
            },
            ],
        };
        }
        return { user };
    }

A note on creating ObjectType or InputType variables with a ?
@ObjectType()
class UserResponse {
  @Field()
  errors?: Error[];
  @Field(() => String)
  user?: User;
}
In the above, we initialize errors and user as undefined.

A note on why ObjectType vs InputType as class declarations.
ObjectTypes we return from our resolvers, whereas InputTypes we receive as arguments.    

What does it do for us to implement our HelloResolver in our src/index.ts schema definition? What this does for us is it defines a graphQL endpoint for our queries.


Before losing your mind on debugging:
Make sure your dist looks the way it should. It's possible that over the course of programming, it gets filled up with a lot of trash (or duplicates from slightly different files). The solution? Erase dist and re-run our `start` and `watch` script, to remake a fresh one.

A note on module not found from the resolvers:
Not sure why, but over in the resolver definitions, we need to need to specify the entity type via the '../entities/post' format, as opposed to the more general 'src/entities/post'. Not sure why.

A note on error TS2307: Cannot find module 'class-validator' or its corresponding type declarations.
For this you need to add 'class-validator' to dev dependencies.

A note on the purpose of our mikro-orm.config.ts:
We make this src/mikro-orm.config.ts in order to be able to access our custom data types from our MikroORM CLI.

A note on why not to use 'ts-node': 
- it's slow
- when we get to production, we don't use ts-node; we compile to JS and execute that. We elect not to use ts-node to be closer to the production environment, in dev
Our solution to ts-node?
- A 'watch' script executing typescript with the watch flag, to monitor file changes to src/index.ts; spits out a dist build (JS) on file change.
- A 'dev' script to execute 'nodemon' on our produced dist directory, coming from the watch script. To the difference of 'node', 'nodemon' will listen for changes made to our compiled dist file, resulting from our watch script.
Note that the two points above must be two scripts running in tandem. We can do this either in two separate terminal instances, or at once via 'concurrently' package.

A note on the difference between orm.em.create, orm.em.persistAndFlush and orm.em.nativeInsert:

A note on node `path` and `__dirname`
These variables come installed in node, and basically they help us ensure that we're running things from the right place, and we have access to the imports we need. __dirname is a pre-defined global variable whose value corresponds to the absolute path leading to the file it's called in (at run time, which is pertinent for us, because we're transpiling before running).

A note on migrations in MikroORM.
After running the $ npx mikro-orm migration:create, from https://mikro-orm.io/docs/migrations/#using-via-cli, we'll have a new migrations directory with the literal SQL generated by our data definitions in our entities. In the migrations, we can see the data types of all of our properties.
We can actually automate the migrations of our 
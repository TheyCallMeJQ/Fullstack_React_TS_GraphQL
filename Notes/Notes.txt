Tutorial reference: https://www.youtube.com/watch?v=I6ypD7qv3Z8&ab_channel=BenAwad

A note on text editors:
I don't give a fuck who you think you are, use VS Code.

A note on extensions:
To see extensions which are currently installed, you can enter into the searchbar command @installed.

VS Code extensions:
- Bracket Pair Colorizer 2 (0.2.0)
- Docker (1.6.0)
- GraphQL for VSCode (1.15.3)
- Prettier - Code formatter (5.7.1)
- Vim (1.17.1) - Disabled for now

How to enable auto-formatting on save for VS Code. 
You can achieve the same result by messing with your settings, which is fine, you can find the relevant config over on the Prettier - Code formatter docs, but you can also do the following, simply via the editor settings:
Code > Preferences > Settings > User. Search for "format", and check "format on save"

Backend init steps:
1. New package.json to backend root
2. Install packages 
    a. devDependencies:
        "@types/node": "^14.11.5",
        "concurrently": "^5.3.0",
        "nodemon": "^2.0.4",
        "ts-node": "^9.0.0",
        "typescript": "^4.0.3"
    b. dependencies:
        "@mikro-orm/cli": "^4.0.7",
        "@mikro-orm/core": "^4.0.7",
        "@mikro-orm/migrations": "^4.0.7",
        "@mikro-orm/postgresql": "^4.0.7",
        "pg": "^8.4.0"    

3. tsconfig.json to backend root
    $ npx tsconfig.json

4. Create the following src/index.ts to test the functionality of the scripts which follow:
//src/index.ts:
console.log('Hello world!');

5. New scripts to package.json (remove comments after copy-paste)
"scripts":[
    //Transpile ts to js, retranspile on file change
    "watch" : "tsc -w",
    //Compile generated js
    "start": "nodemon dist/index.js"
]    

5. Initialize db
    a. if needed, install postgresql 
        $ brew install postgresql
    b. (Optional) add db scripts to package.json, for instance:
        "pg-start": "brew services start postgresql",
        "pg-stop" : "brew services stop postgresql"
    c. (After starting postgresql instance via 'pg-start' script defined above) create new db.
        $ createdb [DB_NAME]

    d. Create a new entity, in accordance with mikro-orm docs: https://mikro-orm.io/docs/defining-entities/
    //entities/Post.ts:
    import { Entity, PrimaryKey, Property } from "@mikro-orm/core";

    @Entity()
    export class Post {
    @PrimaryKey()
    id!: number;

    @Property()
    createdAt = new Date();

    @Property({ onUpdate: () => new Date() })
    updatedAt = new Date();

    @Property()
    title!: string;
    }

    e. Have the following src/index.ts (it will result in an error, as right now we're trying to create entries somewhere that doesn't exist yet):
    import { MikroORM } from "@mikro-orm/core";
    import { __prod__ } from "./constants";
    import { Post } from "./entities/Post";

    const main = async () => {
    console.log("Hello orld");
    const orm = await MikroORM.init({
        dbName: "lireddit",
        entities: [Post],
        type: "postgresql",
        debug: !__prod__,
    });

    //Create a new Post (does not affect db)
    const post = orm.em.create(Post, { title: "My first post" });
    await orm.em.persistAndFlush(post);
    console.log("--------------SQL 2-------------------");
    await orm.em.persistAndFlush(post);
    };

    main().catch((e) => {
    console.log(e);
    });

    f. Set up MikroORM CLI to allow for ops to db.
        i. Navigate to https://mikro-orm.io/docs/installation#setting-up-the-commandline-tool
        ii. Have the following general package.json:
        {
            "name": "your-app",
            "dependencies": { ... },
            "mikro-orm": {
                "useTsNode": true,
                "configPaths": [
                "./src/mikro-orm.config.ts",
                "./dist/mikro-orm.config.js"
                ]
            }
        }
        iii. Create above specified 'src/mikro-orm.config.ts' with the following:
        


A note on why not to use 'ts-node': 
- it's slow
- when we get to production, we don't use ts-node; we compile to JS and execute that. We elect not to use ts-node to be closer to the production environment, in dev
Our solution to ts-node?
- A 'watch' script executing typescript with the watch flag, to monitor file changes to src/index.ts; spits out a dist build (JS) on file change.
- A 'dev' script to execute 'nodemon' on our produced dist directory, coming from the watch script. To the difference of 'node', 'nodemon' will listen for changes made to our compiled dist file, resulting from our watch script.
Note that the two points above must be two scripts running in tandem. We can do this either in two separate terminal instances, or at once via 'concurrently' package.

A note on the difference between orm.em.create, orm.em.persistAndFlush and orm.em.nativeInsert:
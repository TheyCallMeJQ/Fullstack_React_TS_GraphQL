Tutorial reference: https://www.youtube.com/watch?v=I6ypD7qv3Z8&ab_channel=BenAwad

A note on extensions:
To see extensions which are currently installed, you can enter into the searchbar command @installed.

VS Code extensions:
- Bracket Pair Colorizer 2 (0.2.0)
- Docker (1.6.0)
- GraphQL for VSCode (1.15.3)
- Prettier - Code formatter (5.7.1)
- Vim (1.17.1) - Disabled for now

Backend init steps:
1. New package.json to backend root
2. devDependencies:
    - typescript
    - @types/node
    - ts-node
3. tsconfig.json to backend root
    $ npx tsconfig.json
4. New scripts to package.json (remove comments)
"scripts":[
    //Compile typescript file
    "start": "ts-node src/index.ts",
    //Run typescript with the -w watch flag, spit out dist folder
    "watch" : "tsc -w",
]    

A note on why not to use 'ts-node': 
- it's slow
- when we get to production, we don't use ts-node; we compile to JS and execute that. We elect not to use ts-node to be closer to the production environment, in dev
Our solution to ts-node?
- A 'watch' script executing typescript with the watch flag, to monitor file changes to src/index.ts; spits out a dist build (JS) on file change.
- A 'dev' script to execute 'nodemon' on our produced dist directory, coming from the watch script. To the difference of 'node', 'nodemon' will listen for changes made to our compiled dist file, resulting from our watch script.
Note that the two points above must be two scripts running in tandem.